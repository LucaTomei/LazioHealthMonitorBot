---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\authorized_users.json ---- 
[
] 
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\input_prescriptions.json ---- 
[] 
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\locations.json ---- 
{} 
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\previous_data.json ---- 
{} 
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\config.py ---- 
import os
import logging
from logging.handlers import RotatingFileHandler

# Configurazione del logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        # File handler con rotazione: max 1MB per file, massimo 5 file
        RotatingFileHandler(
            "recup_monitor.log", 
            maxBytes=1024*1024,  # 1MB
            backupCount=5        # Mantiene 5 file di backup
        ),
        logging.StreamHandler()  # Stampa anche sulla console
    ]
)
logger = logging.getLogger("RecupMonitor")

# Base configuration
BASE_URL = "https://recup-webapi-appmobile.regione.lazio.it"
AUTH_HEADER = "Basic QVBQTU9CSUxFX1NQRUNJQUw6UGs3alVTcDgzbUh4VDU4NA=="

# Configurazione Telegram
TELEGRAM_TOKEN = ""

# Percorso del file di input e dati precedenti
INPUT_FILE = "input_prescriptions.json"
PREVIOUS_DATA_FILE = "previous_data.json"
USERS_FILE = "authorized_users.json"

# Stati per la conversazione
(WAITING_FOR_FISCAL_CODE, WAITING_FOR_NRE, CONFIRM_ADD, 
 WAITING_FOR_PRESCRIPTION_TO_DELETE, WAITING_FOR_PRESCRIPTION_TO_TOGGLE,
 WAITING_FOR_DATE_FILTER, WAITING_FOR_MONTHS_LIMIT, CONFIRM_DATE_FILTER,
 WAITING_FOR_BOOKING_CHOICE, WAITING_FOR_BOOKING_CONFIRMATION, WAITING_FOR_PHONE,
 WAITING_FOR_EMAIL, WAITING_FOR_SLOT_CHOICE, WAITING_FOR_BOOKING_TO_CANCEL,
 WAITING_FOR_AUTO_BOOK_CHOICE, AUTHORIZING) = range(16)  

# Lista di utenti autorizzati
authorized_users = []

# Dizionario per tenere traccia delle conversazioni in corso
user_data = {} 
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\recup_monitor.py ---- 
import multiprocessing
import logging
import os
import asyncio
import time
from datetime import datetime

# Importiamo le configurazioni dal modulo config
from config import logger, TELEGRAM_TOKEN, authorized_users

# Configurazione del logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger("RecupMultiprocess")

def run_telegram_bot(users_list=None):
    """Funzione che esegue il bot Telegram in un processo separato."""
    global authorized_users
    if users_list:
        authorized_users.clear()
        authorized_users.extend(users_list)
    logger.info("Avvio del processo per il bot Telegram")
    try:
        import asyncio
        from telegram.ext import Application
        from modules.bot_handlers import setup_handlers
        
        # Configuriamo un nuovo loop per il processo
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
        
        async def run_bot():
            try:
                # Creiamo l'applicazione
                application = Application.builder().token(TELEGRAM_TOKEN).build()
                
                # Setup dei gestori
                setup_handlers(application)
                
                # Avviamo il bot
                logger.info("Bot Telegram in avvio...")
                await application.initialize()
                await application.start()
                await application.updater.start_polling(allowed_updates=["message", "callback_query"])
                
                # Manteniamo il bot in esecuzione
                while True:
                    await asyncio.sleep(1)
            except Exception as e:
                logger.error(f"Errore durante l'esecuzione del bot: {str(e)}")
                import traceback
                logger.error(traceback.format_exc())
                
                # Riavviamo il bot dopo un errore
                logger.info("Tentativo di riavvio del bot tra 10 secondi...")
                await asyncio.sleep(10)
                return await run_bot()  # Riavvio ricorsivo
        
        # Eseguiamo il bot nel loop
        loop.run_until_complete(run_bot())
    
    except Exception as e:
        logger.error(f"Errore critico nel processo del bot Telegram: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        
def run_monitoring():
    """Funzione che esegue il monitoraggio in un processo separato."""
    logger.info("Avvio del processo per il monitoraggio")
    try:
        import asyncio
        import time
        from datetime import datetime
        
        # Creiamo un nuovo loop per questo processo
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # Funzione migliorata che si riavvia automaticamente in caso di errore
        async def robust_monitoring_loop():
            # Carica dati precedenti
            from modules.data_utils import load_previous_data, save_previous_data, load_input_data
            from modules.prescription_processor import process_prescription
            
            previous_data = load_previous_data()
            
            while True:
                try:
                    start_time = time.time()
                    logger.info(f"Inizio ciclo di monitoraggio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                    
                    # Carichiamo i dati delle prescrizioni
                    prescriptions = load_input_data()
                    
                    # Process each prescription
                    for prescription in prescriptions:
                        try:
                            process_prescription(prescription, previous_data)
                        except Exception as e:
                            logger.error(f"Errore nel processare la prescrizione {prescription.get('nre', 'sconosciuta')}: {str(e)}")
                            import traceback
                            logger.error(traceback.format_exc())
                        
                        # Breve pausa tra una prescrizione e l'altra
                        await asyncio.sleep(1)
                    
                    # Salviamo i dati aggiornati
                    save_previous_data(previous_data)
                    
                    # Calcoliamo il tempo di attesa per mantenere cicli di 5 minuti
                    elapsed = time.time() - start_time
                    sleep_time = max(300 - elapsed, 1)  # 300 secondi = 5 minuti
                    
                    logger.info(f"Ciclo completato in {elapsed:.2f} secondi. In attesa del prossimo ciclo tra {sleep_time:.2f} secondi.")
                    await asyncio.sleep(sleep_time)
                    
                except Exception as e:
                    logger.error(f"Errore nel ciclo di monitoraggio: {str(e)}")
                    import traceback
                    logger.error(traceback.format_exc())
                    
                    # In caso di errore, aspetta 60 secondi e riprova
                    logger.info("Riavvio del ciclo di monitoraggio tra 60 secondi...")
                    await asyncio.sleep(60)
        
        # Avvia il loop di monitoraggio
        loop.run_until_complete(robust_monitoring_loop())
    
    except Exception as e:
        logger.error(f"Errore critico nel processo di monitoraggio: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())

def main():
    """Funzione principale che avvia il sistema multi-processo."""
    logger.info("Avvio del sistema multi-processo")
    
    # Caricamento configurazioni e dati comuni
    from modules.data_utils import load_authorized_users
    load_authorized_users()
    
    users = list(authorized_users)
    
    if not authorized_users:
        logger.warning("Nessun utente autorizzato trovato! Il sistema aspetterà l'aggiunta manuale di un utente.")
    
    # Impostazioni avanzate per i processi separati
    # Questa modifica fa sì che i processi siano completamente indipendenti
    mp_context = multiprocessing.get_context('spawn')
    
    # Creiamo e avviamo il processo per il bot Telegram
    #bot_process = mp_context.Process(target=run_telegram_bot)
    bot_process = mp_context.Process(target=run_telegram_bot, args=(users,))

    bot_process.daemon = True  # Il processo terminerà quando il processo principale termina
    bot_process.start()
    
    # Creiamo e avviamo il processo per il monitoraggio
    monitoring_process = mp_context.Process(target=run_monitoring)
    monitoring_process.daemon = True
    monitoring_process.start()
    
    # Attendiamo che i processi terminino (non dovrebbe mai accadere a meno di errori)
    logger.info("Sistema multi-processo avviato. Processi in esecuzione.")
    
    try:
        # Invece di fare join direttamente, controlliamo periodicamente lo stato
        while bot_process.is_alive() and monitoring_process.is_alive():
            time.sleep(1)  # Controlliamo ogni secondo
            
        # Se siamo qui, uno dei processi è terminato inaspettatamente
        if not bot_process.is_alive():
            logger.error("Il processo del bot Telegram è terminato inaspettatamente, riavvio...")
            bot_process = mp_context.Process(target=run_telegram_bot)
            bot_process.daemon = True
            bot_process.start()
        
        if not monitoring_process.is_alive():
            logger.error("Il processo di monitoraggio è terminato inaspettatamente, riavvio...")
            monitoring_process = mp_context.Process(target=run_monitoring)
            monitoring_process.daemon = True
            monitoring_process.start()
            
    except KeyboardInterrupt:
        logger.info("Interruzione richiesta dall'utente, terminazione dei processi...")
        bot_process.terminate()
        monitoring_process.terminate()
        bot_process.join(timeout=5)
        monitoring_process.join(timeout=5)
        logger.info("Processi terminati correttamente.")
    except Exception as e:
        logger.error(f"Errore nel sistema multi-processo: {str(e)}")
        bot_process.terminate()
        monitoring_process.terminate()
        bot_process.join(timeout=5)
        monitoring_process.join(timeout=5)

if __name__ == "__main__":
    main() 
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\modules\api_client.py ---- 
import requests
import logging

from config import (
    logger, BASE_URL, AUTH_HEADER
)

def get_access_token():
    """Obtain access token from the authentication endpoint."""
    token_url = "https://gwapi-az.servicelazio.it/token"
    headers = {
        "Accept": "application/json",
        "Content-Type": "application/x-www-form-urlencoded; charset=utf-8",
        "Authorization": "Basic aFJaMkYxNkthcWQ5dzZxRldEVEhJbHg3UnVRYTpnaUVHbEp4a0Iza1VBdWRLdXZNdFBJaTVRc2th",
        "Accept-Language": "it-IT;q=1.0",
        "User-Agent": "RLGEOAPP/2.2.0 (it.laziocrea.rlgeoapp; build:2.2.0; iOS 18.3.1) Alamofire/5.10.2"
    }
    
    data = {
        "grant_type": "client_credentials"
    }
    
    try:
        response = requests.post(token_url, headers=headers, data=data)
        response.raise_for_status()
        return response.json()['access_token']
    except Exception as e:
        logger.error(f"Errore nell'ottenere il token di accesso: {str(e)}")
        return None

def update_device_token(access_token):
    """Update device token."""
    # Questa funzione può fallire senza compromettere il funzionamento principale
    try:
        url = f"{BASE_URL}/salute/1.0/notifiche/dispositivo/ct6U4eGiTUfJlh-8la_XTW%3AAPA91bGpiDbgIPrQ4HRF6xB2TembPIAtwywCde0hsMEplYm9DLxaws-bUokiv3bwcLyMrYI3ZyKEj6_Gi8FT4jY2w-8-ajUJeH-qdVRFHWdUgLZvYg-ZxVk"
        
        headers = {
            "Accept-Encoding": "application/json; charset=utf-8",
            "Accept-Language": "it-IT;q=1.0",
            "User-Agent": "RLGEOAPP/2.2.0 (it.laziocrea.rlgeoapp; build:2.2.0; iOS 18.3.1) Alamofire/5.10.2",
            "Accept": "application/json",
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }
        
        data = {
            "token_new": "ct6U4eGiTUfJlh-8la_XTW:APA91bGpiDbgIPrQ4HRF6xB2TembPIAtwywCde0hsMEplYm9DLxaws-bUokiv3bwcLyMrYI3ZyKEj6_Gi8FT4jY2w-8-ajUJeH-qdVRFHWdUgLZvYg-ZxVk"
        }
        
        response = requests.put(url, headers=headers, json=data)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        logger.warning(f"Avviso: impossibile aggiornare il token del dispositivo: {str(e)}")
        # Continuiamo comunque l'esecuzione
        return None

def get_patient_info(fiscal_code):
    """Retrieve patient information."""
    url = f"{BASE_URL}/api/v3/system-apis/patients"
    
    headers = {
        "Connection": "keep-alive",
        "Authorization": AUTH_HEADER,
        "Accept-Language": "it-IT,it;q=0.9",
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Accept": "*/*",
        "Accept-Encoding": "gzip",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0"
    }
    
    params = {
        "fiscalCode": fiscal_code
    }
    
    try:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        logger.error(f"Errore nell'ottenere informazioni sul paziente {fiscal_code}: {str(e)}")
        return None

def get_doctor_info(fiscal_code):
    """Get doctor information."""
    url = f"{BASE_URL}/api/v4/experience-apis/doctors/bpx"
    
    headers = {
        "Connection": "keep-alive",
        "Authorization": AUTH_HEADER,
        "Accept-Language": "it-IT,it;q=0.9",
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Accept": "*/*",
        "Accept-Encoding": "gzip",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0",
        "Content-Type": "application/json"
    }
    
    data = {
        "personIdentifier": fiscal_code
    }
    
    try:
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        logger.error(f"Errore nell'ottenere le informazioni del medico per {fiscal_code}: {str(e)}")
        return None

def book_appointment(process_id, data_prenotazione, diary_id, service_cur, nre, fiscal_code):
    """
    Perform prebooking for an appointment.
    
    This function matches the API call in 1.har, creating a temporary hold on the appointment slot.
    """
    url = f"{BASE_URL}/api/v4/experience-apis/doctors/bpx/{process_id}/prebooking"
    
    headers = {
        "Accept": "*/*",
        "Content-Type": "application/json",
        "Accept-Language": "it-IT,it;q=0.9",
        "Authorization": AUTH_HEADER,
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Connection": "keep-alive",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0",
        "Accept-Encoding": "gzip"
    }
    
    payload = {
        "date": data_prenotazione,
        "diaryId": diary_id,
        "requestId": "A0",
        "supplyModeId": "A",
        "extraServices": [],
        "serviceCur": service_cur,
        "exemptionId": "NE00",
        "priority": "P",
        "nre": nre,
        "processId": process_id,
        "personIdentifier": fiscal_code
    }
    
    response = requests.post(url, headers=headers, json=payload, verify=False)
    
    # More detailed logging for debugging
    print(f"Pre-booking Status Code: {response.status_code}")
    
    if response.status_code != 201:  # The API returns 201 Created for successful prebookings
        print(f"Pre-booking Error Response: {response.text}")
        raise Exception(f"Pre-booking failed with status code {response.status_code}")
    
    return response.json()

def complete_booking(fiscal_code, process_id, nre, phone_number, email, lock_id, order_id, data_prenotazione, diary_id):
    """
    Complete the booking process after a successful prebooking.
    
    This function matches the API call in 2.har, finalizing the appointment reservation.
    """
    url = f"{BASE_URL}/api/v4/process-apis/booking-management/bookings"
    
    headers = {
        "Accept": "*/*",
        "Content-Type": "application/json",
        "Accept-Language": "it-IT,it;q=0.9",
        "Authorization": AUTH_HEADER,
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Connection": "keep-alive",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0",
        "Accept-Encoding": "gzip"
    }
    
    # This payload structure exactly matches what's in 2.har
    payload = {
        "prescriptionNumber": nre,
        "processId": process_id,
        "diaryId": diary_id,  # Ora passato come parametro
        "contacts": {
            "phoneNumber": phone_number,
            "email": email
        },
        "startTime": data_prenotazione,
        "services": [{
            "id": order_id,
            "requestId": "A0"
        }],
        "lockId": lock_id,
        "personIdentifier": fiscal_code,
        "status": "PRENOTATA",
        "supplyModeId": "A"
    }
    
    response = requests.post(url, headers=headers, json=payload, verify=False)
    
    # Enhanced error handling and logging
    print(f"Complete Booking Status Code: {response.status_code}")
    
    if response.status_code != 200:
        print(f"Complete Booking Error Response: {response.text}")
        raise Exception(f"Booking completion failed with status code {response.status_code}")
    
    result = response.json()
    
    # Extract booking ID with robust error handling
    booking_id = None
    if 'id' in result:
        booking_id = result['id']
    elif 'content' in result and result['content'] and 'id' in result['content'][0]:
        booking_id = result['content'][0]['id']
    else:
        print("Warning: Could not find booking ID in response")
        print(f"Response content: {result}")
    
    return result, booking_id

def get_booking_document(booking_id, output_path=None):
    """
    Retrieve the booking document (PDF) and save it locally.
    
    This function matches the API call in 3.har.
    """
    url = f"{BASE_URL}/api/v3/process-apis/booking-management/bookings/{booking_id}/documents"
    
    headers = {
        "Accept": "*/*",
        "Accept-Language": "it-IT,it;q=0.9",
        "Authorization": AUTH_HEADER,
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Connection": "keep-alive",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0",
        "Accept-Encoding": "gzip"
    }
    
    response = requests.get(url, headers=headers, verify=False)
    
    # Enhanced error handling
    if response.status_code != 200:
        print(f"Get Document Error: Status Code {response.status_code}")
        print(f"Response content: {response.text}")
        raise Exception(f"Failed to retrieve booking document with status code {response.status_code}")
    
    # If we need to save the PDF
    if output_path is None:
        # Create a default filename with booking ID and timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_path = f"booking_{booking_id}_{timestamp}.pdf"
    
    # Save the PDF to disk
    with open(output_path, 'wb') as f:
        f.write(response.content)
    
    print(f"✅ Booking document saved to: {output_path}")
    return output_path

def cancel_booking(booking_id):
    """
    Cancel a specific booking.
    
    This function matches the API call in 6.har.
    """
    url = f"{BASE_URL}/api/v3/process-apis/booking-management/bookings"
    
    headers = {
        "Accept": "*/*",
        "Content-Type": "application/json",
        "Accept-Language": "it-IT,it;q=0.9",
        "Authorization": AUTH_HEADER,
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Connection": "keep-alive",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0",
        "Accept-Encoding": "gzip"
    }
    
    # This payload structure exactly matches what's in 6.har
    payload = [{
        "reasonId": 4,  # Reason code for cancellation
        "bookingStatus": "ELIMINATA",
        "identifiedBy": "ID_DI_SISTEMA",
        "identifier": booking_id
    }]
    
    response = requests.patch(url, headers=headers, json=payload, verify=False)
    
    # Better error handling
    if response.status_code != 200:
        print(f"Cancellation Error: Status Code {response.status_code}")
        print(f"Response content: {response.text}")
        raise Exception(f"Booking cancellation failed with status code {response.status_code}")
    
    result = response.json()
    
    # Check if cancellation was successful using the results
    if result and '_messages' in result:
        if not result['_messages']:
            print("✅ Booking successfully canceled")
        else:
            print("⚠️ Cancellation may have issues:", result['_messages'])
    else:
        print("✅ Booking canceled successfully")
    
    return result


def check_prescription(patient_id, nre):
    """Check prescription details."""
    url = f"{BASE_URL}/api/v3/experience-apis/citizens/prescriptions/check-prescription"
    
    headers = {
        "Connection": "keep-alive",
        "Authorization": AUTH_HEADER,
        "Accept-Language": "it-IT,it;q=0.9",
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Accept": "*/*",
        "Accept-Encoding": "gzip",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0"
    }
    
    params = {
        "patientId": patient_id,
        "nre": nre
    }
    
    try:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        logger.error(f"Errore nel controllare la prescrizione {nre}: {str(e)}")
        return None

def get_prescription_details(patient_id, nre):
    """Get full prescription details."""
    url = f"{BASE_URL}/api/v3/system-apis/prescriptions/{nre}"
    
    headers = {
        "Connection": "keep-alive",
        "Authorization": AUTH_HEADER,
        "Accept-Language": "it-IT,it;q=0.9",
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Accept": "*/*",
        "Accept-Encoding": "gzip",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0"
    }
    
    params = {
        "patientId": patient_id
    }
    
    try:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        logger.error(f"Errore nell'ottenere i dettagli della prescrizione {nre}: {str(e)}")
        return None

def get_availabilities(patient_id, process_id, nre, order_ids):
    """Get medical service availabilities."""
    url = f"{BASE_URL}/api/v3/experience-apis/citizens/availabilities"
    
    headers = {
        "Connection": "keep-alive",
        "Authorization": AUTH_HEADER,
        "Accept-Language": "it-IT,it;q=0.9",
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Accept": "*/*",
        "Accept-Encoding": "gzip",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0"
    }
    
    params = {
        "personId": patient_id,
        "processId": process_id,
        "nre": nre,
        "orderIds": order_ids,
        "prescriptionPriority": "P",
        "firstBy": "hospital-best-10"
    }
    
    try:
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        logger.error(f"Errore nell'ottenere le disponibilità per {nre}: {str(e)}")
        return None 
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\modules\booking_client.py ---- 
import requests
import base64
import json
import urllib3
import time
import os
from datetime import datetime
import logging

# Importiamo il logger dal modulo principale
from recup_monitor import logger

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Base configuration
BASE_URL = "https://recup-webapi-appmobile.regione.lazio.it"
AUTH_HEADER = "Basic QVBQTU9CSUxFX1NQRUNJQUw6UGs3alVTcDgzbUh4VDU4NA=="

def book_appointment(process_id, data_prenotazione, diary_id, service_cur, nre, fiscal_code):
    """
    Perform prebooking for an appointment.
    
    This function creates a temporary hold on the appointment slot.
    """
    url = f"{BASE_URL}/api/v4/experience-apis/doctors/bpx/{process_id}/prebooking"
    
    headers = {
        "Accept": "*/*",
        "Content-Type": "application/json",
        "Accept-Language": "it-IT,it;q=0.9",
        "Authorization": AUTH_HEADER,
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Connection": "keep-alive",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0",
        "Accept-Encoding": "gzip"
    }
    
    payload = {
        "date": data_prenotazione,
        "diaryId": diary_id,
        "requestId": "A0",
        "supplyModeId": "A",
        "extraServices": [],
        "serviceCur": service_cur,
        "exemptionId": "NE00",
        "priority": "P",
        "nre": nre,
        "processId": process_id,
        "personIdentifier": fiscal_code
    }
    
    response = requests.post(url, headers=headers, json=payload, verify=False)
    
    # More detailed logging for debugging
    logger.info(f"Pre-booking Status Code: {response.status_code}")
    
    if response.status_code != 201:  # The API returns 201 Created for successful prebookings
        logger.error(f"Pre-booking Error Response: {response.text}")
        raise Exception(f"Pre-booking failed with status code {response.status_code}")
    
    return response.json()

def complete_booking(fiscal_code, process_id, nre, phone_number, email, lock_id, order_id, data_prenotazione, diary_id):
    """
    Complete the booking process after a successful prebooking.
    
    This function finalizes the appointment reservation.
    """
    url = f"{BASE_URL}/api/v4/process-apis/booking-management/bookings"
    
    headers = {
        "Accept": "*/*",
        "Content-Type": "application/json",
        "Accept-Language": "it-IT,it;q=0.9",
        "Authorization": AUTH_HEADER,
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Connection": "keep-alive",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0",
        "Accept-Encoding": "gzip"
    }
    
    # This payload structure matches what's needed for the API
    payload = {
        "prescriptionNumber": nre,
        "processId": process_id,
        "diaryId": diary_id,
        "contacts": {
            "phoneNumber": phone_number,
            "email": email
        },
        "startTime": data_prenotazione,
        "services": [{
            "id": order_id,
            "requestId": "A0"
        }],
        "lockId": lock_id,
        "personIdentifier": fiscal_code,
        "status": "PRENOTATA",
        "supplyModeId": "A"
    }
    
    response = requests.post(url, headers=headers, json=payload, verify=False)
    
    # Enhanced error handling and logging
    logger.info(f"Complete Booking Status Code: {response.status_code}")
    
    if response.status_code != 200:
        logger.error(f"Complete Booking Error Response: {response.text}")
        raise Exception(f"Booking completion failed with status code {response.status_code}")
    
    result = response.json()
    
    # Extract booking ID with robust error handling
    booking_id = None
    if 'id' in result:
        booking_id = result['id']
    elif 'content' in result and result['content'] and 'id' in result['content'][0]:
        booking_id = result['content'][0]['id']
    else:
        logger.warning("Could not find booking ID in response")
        logger.debug(f"Response content: {result}")
    
    return result, booking_id

def get_booking_document(booking_id, output_path=None):
    """
    Retrieve the booking document (PDF) and save it locally.
    """
    url = f"{BASE_URL}/api/v3/process-apis/booking-management/bookings/{booking_id}/documents"
    
    headers = {
        "Accept": "*/*",
        "Accept-Language": "it-IT,it;q=0.9",
        "Authorization": AUTH_HEADER,
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Connection": "keep-alive",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0",
        "Accept-Encoding": "gzip"
    }
    
    response = requests.get(url, headers=headers, verify=False)
    
    # Enhanced error handling
    if response.status_code != 200:
        logger.error(f"Get Document Error: Status Code {response.status_code}")
        logger.error(f"Response content: {response.text}")
        raise Exception(f"Failed to retrieve booking document with status code {response.status_code}")
    
    # If we need to save the PDF
    if output_path is None:
        # Create a default filename with booking ID and timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_path = f"booking_{booking_id}_{timestamp}.pdf"
    
    # Save the PDF to disk
    with open(output_path, 'wb') as f:
        f.write(response.content)
    
    logger.info(f"Booking document saved to: {output_path}")
    return output_path, response.content

def cancel_booking(booking_id):
    """
    Cancel a specific booking.
    """
    logger.info(f"Tentativo di cancellazione prenotazione con ID: {booking_id}")
    
    url = f"{BASE_URL}/api/v3/process-apis/booking-management/bookings"
    
    headers = {
        "Accept": "*/*",
        "Content-Type": "application/json",
        "Accept-Language": "it-IT,it;q=0.9",
        "Authorization": AUTH_HEADER,
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Connection": "keep-alive",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0",
        "Accept-Encoding": "gzip"
    }
    
    # Payload per la cancellazione
    payload = [{
        "reasonId": 4,  # Reason code for cancellation
        "bookingStatus": "ELIMINATA",
        "identifiedBy": "ID_DI_SISTEMA",
        "identifier": booking_id
    }]
    
    logger.info(f"Payload cancellazione: {payload}")
    
    try:
        response = requests.patch(url, headers=headers, json=payload, verify=False)
        
        # Log della risposta
        logger.info(f"Status code risposta: {response.status_code}")
        logger.info(f"Contenuto risposta: {response.text[:500]}")  # Limitiamo per sicurezza
        
        if response.status_code != 200:
            logger.error(f"Errore nella cancellazione: {response.status_code}")
            logger.error(f"Risposta errore: {response.text}")
            raise Exception(f"Cancellazione prenotazione fallita con codice {response.status_code}")
        
        result = response.json()
        logger.info(f"Risposta JSON: {result}")
        
        return result
    except Exception as e:
        logger.error(f"Eccezione durante la cancellazione: {str(e)}")
        raise
    
def booking_workflow(fiscal_code, nre, phone_number, email, patient_id=None, process_id=None, slot_choice=0):
    """
    Complete booking workflow - from checking availability to booking and downloading confirmation.
    
    Parameters:
    fiscal_code (str): The fiscal code of the patient
    nre (str): The prescription number
    phone_number (str): Contact phone number
    email (str): Contact email
    patient_id (str, optional): If already known, patient ID to skip a step
    process_id (str, optional): If already known, process ID to skip a step
    slot_choice (int, optional): Index of the slot to choose (0 = first available)
    
    Returns:
    dict: Result of the booking operation with details
    """
    from modules.api_client import (
        get_patient_info, get_doctor_info, check_prescription,
        get_prescription_details, get_availabilities
    )
    
    try:
        # Step 1: Get patient information if not provided
        if not patient_id:
            patient_info = get_patient_info(fiscal_code)
            if not patient_info or 'content' not in patient_info or not patient_info['content']:
                return {"success": False, "message": f"Impossibile trovare informazioni per il paziente {fiscal_code}"}
            patient_id = patient_info['content'][0]['id']
            logger.info(f"Patient ID: {patient_id}")
        
        # Step 2: Get doctor information if not provided
        if not process_id:
            doctor_info = get_doctor_info(fiscal_code)
            if not doctor_info or 'id' not in doctor_info:
                return {"success": False, "message": f"Impossibile trovare informazioni per il medico del paziente {fiscal_code}"}
            process_id = doctor_info['id']
            logger.info(f"Process ID: {process_id}")
        
        # Step 3: Check prescription
        check_prescription_result = check_prescription(patient_id, nre)
        if not check_prescription_result:
            return {"success": False, "message": f"Impossibile verificare la prescrizione {nre}"}
        logger.info("Prescription Checked")
        
        # Step 4: Get prescription details
        prescription_details = get_prescription_details(patient_id, nre)
        if not prescription_details or 'details' not in prescription_details or not prescription_details['details']:
            return {"success": False, "message": f"Impossibile ottenere i dettagli della prescrizione {nre}"}
        
        order_ids = prescription_details['details'][0]['service']['id']
        service_cur = prescription_details['details'][0]['service']['code']
        service_name = prescription_details['details'][0]['service'].get('description', 'Servizio non specificato')
        logger.info(f"Order ID: {order_ids}")
        
        # Step 5: Get availabilities
        availabilities = get_availabilities(patient_id, process_id, nre, order_ids)
        if not availabilities or 'content' not in availabilities:
            return {"success": False, "message": f"Impossibile ottenere le disponibilità per {nre}"}
        
        logger.info(f"Total available slots: {len(availabilities['content'])}")
        
        # Step 6: List and select slot
        if not availabilities['content']:
            return {"success": False, "message": "Nessuna disponibilità trovata per questa prescrizione"}
        
        # Sort slots by date to prioritize earlier dates
        sorted_slots = sorted(availabilities['content'], key=lambda x: x['date'])
        
        # If slot_choice is out of range, use the first slot
        if slot_choice >= len(sorted_slots):
            slot_choice = 0
            logger.warning(f"Slot choice {slot_choice} out of range, using first available slot")
        
        # Use the selected slot (or return availability list if slot_choice is -1)
        if slot_choice == -1:
            # Return the list of availabilities for user selection
            slot_info = []
            for i, slot in enumerate(sorted_slots):
                slot_info.append({
                    "index": i,
                    "date": slot['date'],
                    "hospital": slot.get('hospital', {}).get('name', 'Unknown'),
                    "address": slot.get('site', {}).get('address', 'Unknown'),
                    "price": slot.get('price', 'N/A')
                })
            return {
                "success": True, 
                "action": "list_slots",
                "service": service_name,
                "slots": slot_info,
                "patient_id": patient_id,
                "process_id": process_id
            }
        
        # Get the selected slot
        selected_slot = sorted_slots[slot_choice]
        diary_id = selected_slot['diary']['id']
        data_prenotazione = selected_slot['date']
        
        logger.info(f"Selected Appointment Details:")
        logger.info(f"Date: {data_prenotazione}")
        logger.info(f"Location: {selected_slot.get('hospital', {}).get('name', 'Unknown')}")
        
        # Step 7: Create pre-booking for the selected slot
        try:
            prebooking_result = book_appointment(
                process_id, 
                data_prenotazione, 
                diary_id, 
                service_cur, 
                nre, 
                fiscal_code
            )
            
            lock_id = prebooking_result['id']
            logger.info(f"Pre-booking successful. Lock ID: {lock_id}")
            
            # Step 8: Complete booking
            booking_result, booking_id = complete_booking(
                fiscal_code, 
                process_id, 
                nre, 
                phone_number, 
                email, 
                lock_id, 
                order_ids,
                data_prenotazione,
                diary_id
            )
            
            if not booking_id:
                return {"success": False, "message": "Prenotazione fallita: impossibile ottenere ID prenotazione"}
            
            logger.info(f"Booking completed. Booking ID: {booking_id}")
            
            # Step 9: Download the booking confirmation PDF
            pdf_path, pdf_content = get_booking_document(booking_id)
            
            # Step 10: Return booking information
            return {
                "success": True,
                "action": "booked",
                "booking_id": booking_id,
                "pdf_path": pdf_path,
                "pdf_content": pdf_content,
                "appointment_date": data_prenotazione,
                "hospital": selected_slot.get('hospital', {}).get('name', 'Unknown'),
                "address": selected_slot.get('site', {}).get('address', 'Unknown'),
                "service": service_name
            }
        
        except Exception as e:
            logger.error(f"Error booking slot {data_prenotazione}: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return {"success": False, "message": f"Errore durante la prenotazione: {str(e)}"}
            
    except Exception as e:
        logger.error(f"An error occurred in booking workflow: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        return {"success": False, "message": f"Errore durante il processo di prenotazione: {str(e)}"}

def get_user_bookings(fiscal_code):
    """
    Get a list of active bookings for a user.
    
    Parameters:
    fiscal_code (str): The fiscal code of the patient
    
    Returns:
    list: List of active bookings
    """
    url = f"{BASE_URL}/api/v3/process-apis/booking-management/bookings/search"
    
    headers = {
        "Accept": "*/*", 
        "Content-Type": "application/json",
        "Accept-Language": "it-IT,it;q=0.9",
        "Authorization": AUTH_HEADER,
        "Host": "recup-webapi-appmobile.regione.lazio.it",
        "Connection": "keep-alive",
        "User-Agent": "salutelazio/2.2.0 CFNetwork/3826.400.120 Darwin/24.3.0",
        "Accept-Encoding": "gzip"
    }
    
    payload = {
        "fiscalCode": fiscal_code,
        "statuses": ["PRENOTATA", "PRESA_IN_CARICO"]
    }
    
    try:
        response = requests.post(url, headers=headers, json=payload, verify=False)
        response.raise_for_status()
        
        result = response.json()
        
        if 'content' in result:
            return {
                "success": True,
                "bookings": result['content']
            }
        else:
            return {
                "success": True,
                "bookings": []
            }
    except Exception as e:
        logger.error(f"Error getting user bookings: {str(e)}")
        return {
            "success": False,
            "message": f"Errore nel recupero delle prenotazioni: {str(e)}"
        } 
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\modules\bot_handlers.py ---- 
import re
import asyncio
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, MessageHandler, CallbackQueryHandler,
    ContextTypes, ConversationHandler, filters
)

from modules.booking_client import (
    booking_workflow, cancel_booking, get_booking_document, 
    get_user_bookings
)
from datetime import datetime
from io import BytesIO

# Importiamo le variabili globali dal modulo principale
from config import (
    logger, user_data, authorized_users,
    WAITING_FOR_FISCAL_CODE, WAITING_FOR_NRE, CONFIRM_ADD,
    WAITING_FOR_PRESCRIPTION_TO_DELETE, WAITING_FOR_PRESCRIPTION_TO_TOGGLE,
    WAITING_FOR_DATE_FILTER, WAITING_FOR_MONTHS_LIMIT, CONFIRM_DATE_FILTER,
    WAITING_FOR_BOOKING_CHOICE, WAITING_FOR_BOOKING_CONFIRMATION, WAITING_FOR_PHONE,
    WAITING_FOR_EMAIL, WAITING_FOR_SLOT_CHOICE, WAITING_FOR_BOOKING_TO_CANCEL, WAITING_FOR_AUTO_BOOK_CHOICE, AUTHORIZING
)

# Importiamo le funzioni da altri moduli
from modules.data_utils import (
    load_authorized_users, save_authorized_users, 
    load_input_data, save_input_data,
    load_previous_data, save_previous_data
)
from modules.prescription_processor import process_prescription

# =============================================================================
# FUNZIONI DI UTILITY PER IL BOT
# =============================================================================

async def send_telegram_message(chat_id, text, parse_mode="HTML"):
    """Invia un messaggio Telegram."""
    try:
        import requests
        
        from recup_monitor import TELEGRAM_TOKEN
        
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        data = {
            "chat_id": chat_id,
            "text": text,
            "parse_mode": parse_mode
        }
        
        response = requests.post(url, data=data, timeout=10)
        response.raise_for_status()
        
        return True
    except Exception as e:
        logger.error(f"Errore nell'inviare messaggio Telegram: {str(e)}")
        return False

# =============================================================================
# GESTORI COMANDI BOT
# =============================================================================
def get_safe_description(prescription):
    """
    Ottiene una descrizione sicura dalla prescrizione.
    
    Args:
        prescription (dict): La prescrizione da cui ottenere la descrizione
        
    Returns:
        str: Una descrizione sicura
    """
    description = prescription.get('description', '')
    if not description:
        # Se la descrizione non è disponibile, usiamo l'NRE
        description = f"Prescrizione {prescription.get('nre', 'sconosciuta')}"
    return description
    
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestore del comando /start."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text(
            "🔒 Non sei autorizzato ad utilizzare questo bot. Contatta l'amministratore per ottenere l'accesso."
        )
        logger.warning(f"Tentativo di accesso non autorizzato da {user_id}")
        return
    
    # Creiamo una tastiera personalizzata con tutte le funzionalità
    keyboard = [
        ["➕ Aggiungi Prescrizione", "➖ Rimuovi Prescrizione"],
        ["📋 Lista Prescrizioni", "🔄 Verifica Disponibilità"],
        ["🔔 Gestisci Notifiche", "⏱ Imposta Filtro Date"],
        ["🏥 Prenota", "🤖 Prenota Automaticamente"],
        ["📝 Le mie Prenotazioni", "ℹ️ Informazioni"],
        ["🔑 Autorizza Utente"]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    await update.message.reply_text(
        f"👋 Benvenuto, {update.effective_user.first_name}!\n\n"
        "Questo bot ti aiuterà a monitorare le disponibilità del Servizio Sanitario Nazionale.\n\n"
        "Utilizza i pulsanti sotto per gestire le prescrizioni da monitorare.",
        reply_markup=reply_markup
    )
    
# =============================================================================
# GESTORI PRESCRIZIONI: AGGIUNTA
# =============================================================================

async def add_prescription(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce l'aggiunta di una nuova prescrizione."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text("🔒 Non sei autorizzato ad utilizzare questa funzione.")
        return
    
    # Tastiera con pulsante Annulla
    cancel_keyboard = ReplyKeyboardMarkup([["❌ Annulla"]], resize_keyboard=True)
    
    await update.message.reply_text(
        "Per aggiungere una nuova prescrizione da monitorare, ho bisogno di alcune informazioni.\n\n"
        "Per prima cosa, inserisci il codice fiscale del paziente:",
        reply_markup=cancel_keyboard
    )
    
    # Inizializziamo i dati dell'utente
    user_data[user_id] = {"action": "add_prescription"}
    
    return WAITING_FOR_FISCAL_CODE

async def cancel_operation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Annulla l'operazione corrente e torna al menu principale."""
    try:
        user_id = None
        
        # Gestione diversa se la cancellazione viene da un callback o da un messaggio
        if update.callback_query:
            # Cancellazione da una callback query
            query = update.callback_query
            await query.answer()
            user_id = query.from_user.id
            await query.edit_message_text("❌ Operazione annullata.")
        elif update.message:
            # Cancellazione da un messaggio di testo
            user_id = update.effective_user.id
            # Ripristiniamo la tastiera principale
            main_keyboard = ReplyKeyboardMarkup([
                ["➕ Aggiungi Prescrizione", "➖ Rimuovi Prescrizione"],
                ["📋 Lista Prescrizioni", "🔄 Verifica Disponibilità"],
                ["🔔 Gestisci Notifiche", "⏱ Imposta Filtro Date"],
                ["🏥 Prenota", "🤖 Prenota Automaticamente"],
                ["📝 Le mie Prenotazioni", "ℹ️ Informazioni"],
                ["🔑 Autorizza Utente"]
            ], resize_keyboard=True)
            
            await update.message.reply_text(
                "❌ Operazione annullata. Cosa vuoi fare?",
                reply_markup=main_keyboard
            )
        
        # Puliamo i dati dell'utente solo se abbiamo l'ID utente
        if user_id and user_id in user_data:
            user_data.pop(user_id, None)
        
        return ConversationHandler.END
    except Exception as e:
        logger.error(f"Errore in cancel_operation: {str(e)}")
        # In caso di errore, cerchiamo di ripulire i dati
        try:
            if update.effective_user and update.effective_user.id in user_data:
                user_data.pop(update.effective_user.id, None)
            elif update.callback_query and update.callback_query.from_user.id in user_data:
                user_data.pop(update.callback_query.from_user.id, None)
        except:
            pass
        return ConversationHandler.END
        
async def handle_fiscal_code(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce l'input del codice fiscale."""
    user_id = update.effective_user.id
    text = update.message.text.strip()
    
    # Controlliamo se l'utente vuole annullare
    if text == "❌ Annulla" or text.lower() == "/cancel":
        return await cancel_operation(update, context)
    
    fiscal_code = text.upper()
    
    # Validazione base del codice fiscale (16 caratteri alfanumerici)
    if not re.match("^[A-Z0-9]{16}$", fiscal_code):
        await update.message.reply_text(
            "⚠️ Il codice fiscale inserito non sembra valido. Deve essere composto da 16 caratteri alfanumerici.\n\n"
            "Per favore, riprova o scrivi ❌ Annulla per tornare al menu principale:"
        )
        return WAITING_FOR_FISCAL_CODE
    
    # Salviamo il codice fiscale
    user_data[user_id]["fiscal_code"] = fiscal_code
    
    await update.message.reply_text(
        f"Codice fiscale: {fiscal_code}\n\n"
        "Ora inserisci il codice NRE della prescrizione (numero di ricetta elettronica):",
        reply_markup=ReplyKeyboardMarkup([["❌ Annulla"]], resize_keyboard=True)
    )
    
    return WAITING_FOR_NRE

async def handle_nre(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce l'input del codice NRE."""
    user_id = update.effective_user.id
    nre = update.message.text.strip().upper()
    
    # Controlliamo se l'utente vuole annullare
    if nre == "❌ ANNULLA" or nre.lower() == "/cancel":
        return await cancel_operation(update, context)
    
    # Validazione base del codice NRE (15 caratteri alfanumerici)
    if not re.match("^[A-Z0-9]{15}$", nre):
        await update.message.reply_text(
            "⚠️ Il codice NRE inserito non sembra valido. Deve essere composto da 15 caratteri alfanumerici.\n\n"
            "Per favore, riprova:"
        )
        return WAITING_FOR_NRE
    
    # Salviamo il codice NRE
    user_data[user_id]["nre"] = nre
    
    # Carichiamo le prescrizioni esistenti per verificare se è già presente
    prescriptions = load_input_data()
    
    # Controlliamo se la prescrizione esiste già
    fiscal_code = user_data[user_id]["fiscal_code"]
    for prescription in prescriptions:
        if prescription["fiscal_code"] == fiscal_code and prescription["nre"] == nre:
            await update.message.reply_text(
                "⚠️ Questa prescrizione è già presente nel sistema. Non è possibile aggiungerla di nuovo."
            )
            # Puliamo i dati dell'utente
            user_data.pop(user_id, None)
            return ConversationHandler.END
    
    # Chiediamo all'utente il numero di telefono
    await update.message.reply_text(
        f"Codice NRE: {nre}\n\n"
        f"Ora inserisci il tuo numero di telefono per eventuali prenotazioni automatiche:",
        reply_markup=ReplyKeyboardMarkup([["❌ Annulla"]], resize_keyboard=True)
    )
    
    return WAITING_FOR_PHONE

async def handle_add_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce l'input del numero di telefono durante l'aggiunta di prescrizione."""
    user_id = update.effective_user.id
    phone = update.message.text.strip()
    
    # Controlliamo se l'utente vuole annullare
    if phone == "❌ Annulla" or phone.lower() == "/cancel":
        return await cancel_operation(update, context)
    
    # Validazione base del numero di telefono (almeno 8 cifre)
    if not re.match("^[0-9+]{8,15}$", phone):
        await update.message.reply_text(
            "⚠️ Il numero di telefono inserito non sembra valido. Deve contenere almeno 8 cifre.\n\n"
            "Per favore, riprova:"
        )
        return WAITING_FOR_PHONE
    
    # Salviamo il numero di telefono
    user_data[user_id]["phone"] = phone
    
    # Chiediamo l'email
    await update.message.reply_text(
        f"Numero di telefono: {phone}\n\n"
        f"Ora inserisci la tua email per eventuali prenotazioni automatiche:",
        reply_markup=ReplyKeyboardMarkup([["❌ Annulla"]], resize_keyboard=True)
    )
    
    return WAITING_FOR_EMAIL

async def handle_add_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce l'input dell'email durante l'aggiunta di prescrizione."""
    user_id = update.effective_user.id
    email = update.message.text.strip()
    
    # Controlliamo se l'utente vuole annullare
    if email == "❌ Annulla" or email.lower() == "/cancel":
        return await cancel_operation(update, context)
    
    # Verifica che i dati dell'utente siano corretti
    if user_id not in user_data:
        await update.message.reply_text(
            "⚠️ Si è verificato un errore nella sessione. Per favore, ricomincia l'operazione."
        )
        return ConversationHandler.END
    
    # Verifica che sia l'azione corretta
    if user_data[user_id].get("action") != "add_prescription":
        await update.message.reply_text(
            "⚠️ Azione non corretta. Per favore, ricomincia l'operazione."
        )
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Verifica che ci siano i dati necessari
    if "fiscal_code" not in user_data[user_id] or "nre" not in user_data[user_id] or "phone" not in user_data[user_id]:
        await update.message.reply_text(
            "⚠️ Dati incompleti. Per favore, ricomincia l'operazione."
        )
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Validazione base dell'email
    if not re.match(r"[^@]+@[^@]+\.[^@]+", email):
        await update.message.reply_text(
            "⚠️ L'email inserita non sembra valida.\n\n"
            "Per favore, riprova:"
        )
        return WAITING_FOR_EMAIL
    
    # Salviamo l'email
    user_data[user_id]["email"] = email
    
    # Otteniamo i dati necessari
    fiscal_code = user_data[user_id]["fiscal_code"]
    nre = user_data[user_id]["nre"]
    phone = user_data[user_id]["phone"]
    
    await update.message.reply_text(
        f"Stai per aggiungere una nuova prescrizione con i seguenti dati:\n\n"
        f"Codice Fiscale: {fiscal_code}\n"
        f"NRE: {nre}\n"
        f"Telefono: {phone}\n"
        f"Email: {email}\n\n"
        f"Confermi?",
        reply_markup=InlineKeyboardMarkup([
            [
                InlineKeyboardButton("✅ Sì, aggiungi", callback_data="confirm_add"),
                InlineKeyboardButton("❌ No, annulla", callback_data="cancel_add")
            ]
        ])
    )
    
    return CONFIRM_ADD

async def confirm_add_prescription(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la conferma dell'aggiunta di una prescrizione."""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    
    if query.data == "cancel_add":
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Altrimenti, procediamo con l'aggiunta
    fiscal_code = user_data[user_id]["fiscal_code"]
    nre = user_data[user_id]["nre"]
    
    # Otteniamo i dati di contatto
    phone = user_data[user_id]["phone"]
    email = user_data[user_id]["email"]
    
    # Carichiamo le prescrizioni esistenti
    prescriptions = load_input_data()
    
    # Creiamo la nuova prescrizione con notifiche abilitate e configurazione di base
    new_prescription = {
        "fiscal_code": fiscal_code,
        "nre": nre,
        "telegram_chat_id": user_id,
        "notifications_enabled": True,  # Inizializziamo le notifiche come abilitate
        "auto_book_enabled": False,     # Prenotazione automatica disabilitata di default
        "phone": phone,                 # Aggiungiamo il telefono
        "email": email,                 # Aggiungiamo l'email
        "config": {
            "only_new_dates": True,
            "notify_removed": False,
            "min_changes_to_notify": 1,
            "time_threshold_minutes": 60,
            "show_all_current": True,
            "months_limit": None  # Nessun limite di mesi predefinito
        }
    }
    
    # Verifichiamo che la prescrizione sia valida
    previous_data = load_previous_data()
    success, message = process_prescription(new_prescription, previous_data, user_id)
    
    if not success:
        await query.edit_message_text(f"⚠️ Impossibile aggiungere la prescrizione: {message}")
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Aggiungiamo la prescrizione
    prescriptions.append(new_prescription)
    logger.info(f"Prescrizione aggiunta: {new_prescription.get('description', 'Non disponibile')} per {fiscal_code}")
    logger.info(f"Totale prescrizioni: {len(prescriptions)}")
    
    save_input_data(prescriptions)
    save_previous_data(previous_data)
    
    # Aggiorniamo il messaggio
    await query.edit_message_text(
        f"✅ Prescrizione aggiunta con successo!\n\n"
        f"Descrizione: {new_prescription.get('description', 'Non disponibile')}\n"
        f"Codice Fiscale: {fiscal_code}\n"
        f"NRE: {nre}\n\n"
        f"Riceverai notifiche quando saranno disponibili nuovi appuntamenti."
    )
    
    # Suggerimento per la prenotazione automatica
    main_keyboard = ReplyKeyboardMarkup([
        ["➕ Aggiungi Prescrizione", "➖ Rimuovi Prescrizione"],
        ["📋 Lista Prescrizioni", "🔄 Verifica Disponibilità"],
        ["🔔 Gestisci Notifiche", "⏱ Imposta Filtro Date"],
        ["🏥 Prenota", "🤖 Prenota Automaticamente"],
        ["📝 Le mie Prenotazioni", "ℹ️ Informazioni"],
        ["🔑 Autorizza Utente"]
    ], resize_keyboard=True)
    
    await context.bot.send_message(
        chat_id=user_id,
        text="💡 Suggerimento: puoi attivare la prenotazione automatica usando la funzione '🤖 Prenota Automaticamente' "
             "per prenotare automaticamente il primo slot disponibile.",
        reply_markup=main_keyboard
    )
    
    # Puliamo i dati dell'utente
    user_data.pop(user_id, None)
    
    return ConversationHandler.END
    
# =============================================================================
# GESTORI PRESCRIZIONI: RIMOZIONE
# =============================================================================

async def remove_prescription(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la rimozione di una prescrizione."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text("🔒 Non sei autorizzato ad utilizzare questa funzione.")
        return
    
    # Carichiamo le prescrizioni
    prescriptions = load_input_data()
    
    # Filtriamo solo le prescrizioni dell'utente o tutte se è admin
    is_admin = user_id == int(authorized_users[0]) if authorized_users else False
    user_prescriptions = []
    
    if is_admin:
        # L'admin vede tutte le prescrizioni
        user_prescriptions = prescriptions
    else:
        # Gli utenti normali vedono solo le proprie
        user_prescriptions = [p for p in prescriptions if p.get("telegram_chat_id") == user_id]
    
    if not user_prescriptions:
        await update.message.reply_text("⚠️ Non hai prescrizioni da rimuovere.")
        return ConversationHandler.END
    
    # Creiamo i pulsanti per le prescrizioni
    keyboard = []
    
    for idx, prescription in enumerate(user_prescriptions):
        desc = prescription.get("description", "Prescrizione")
        fiscal_code = prescription["fiscal_code"]
        nre = prescription["nre"]
        
        # Creiamo un pulsante con identificativo della prescrizione
        keyboard.append([
            InlineKeyboardButton(
                f"{idx+1}. {desc[:30]}... ({fiscal_code[-4:]})",
                callback_data=f"remove_{idx}"
            )
        ])
    
    # Aggiungiamo un pulsante per annullare
    keyboard.append([InlineKeyboardButton("❌ Annulla", callback_data="cancel_remove")])
    
    # Salviamo le prescrizioni nei dati dell'utente
    user_data[user_id] = {
        "action": "remove_prescription",
        "prescriptions": user_prescriptions
    }
    
    await update.message.reply_text(
        "Seleziona la prescrizione da rimuovere:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    return WAITING_FOR_PRESCRIPTION_TO_DELETE

async def handle_prescription_to_delete(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la selezione della prescrizione da rimuovere."""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    callback_data = query.data
    
    if callback_data == "cancel_remove":
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Estraiamo l'indice della prescrizione
    idx = int(callback_data.split("_")[1])
    user_prescriptions = user_data[user_id]["prescriptions"]
    
    # Controlliamo che l'indice sia valido
    if idx < 0 or idx >= len(user_prescriptions):
        await query.edit_message_text("⚠️ Prescrizione non valida.")
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Otteniamo la prescrizione
    prescription_to_remove = user_prescriptions[idx]
    
    # Carichiamo tutte le prescrizioni
    all_prescriptions = load_input_data()
    
    # Rimuoviamo la prescrizione
    new_prescriptions = []
    removed = False
    
    for prescription in all_prescriptions:
        if (prescription["fiscal_code"] == prescription_to_remove["fiscal_code"] and 
            prescription["nre"] == prescription_to_remove["nre"]):
            removed = True
        else:
            new_prescriptions.append(prescription)
    
    if removed:
        # Salviamo le prescrizioni aggiornate
        save_input_data(new_prescriptions)
        
        # Aggiorniamo il messaggio
        await query.edit_message_text(
            f"✅ Prescrizione rimossa con successo!\n\n"
            f"Descrizione: {prescription_to_remove.get('description', 'Non disponibile')}\n"
            f"Codice Fiscale: {prescription_to_remove['fiscal_code']}\n"
            f"NRE: {prescription_to_remove['nre']}"
        )
    else:
        await query.edit_message_text("⚠️ Impossibile rimuovere la prescrizione.")
    
    # Puliamo i dati dell'utente
    user_data.pop(user_id, None)
    
    return ConversationHandler.END

# =============================================================================
# GESTORI PRESCRIZIONI: LISTA E VERIFICA
# =============================================================================

async def list_prescriptions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra la lista delle prescrizioni monitorate."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text("🔒 Non sei autorizzato ad utilizzare questa funzione.")
        return
    
    # Carichiamo le prescrizioni
    prescriptions = load_input_data()
    
    # Filtriamo solo le prescrizioni dell'utente o tutte se è admin
    is_admin = user_id == int(authorized_users[0]) if authorized_users else False
    
    if is_admin:
        # L'admin vede tutte le prescrizioni
        message = "📋 <b>Tutte le prescrizioni monitorate:</b>\n\n"
    else:
        # Gli utenti normali vedono solo le proprie
        prescriptions = [p for p in prescriptions if p.get("telegram_chat_id") == user_id]
        message = "📋 <b>Le tue prescrizioni monitorate:</b>\n\n"
    
    if not prescriptions:
        await update.message.reply_text(
            "Non ci sono prescrizioni in monitoraggio." if is_admin else "Non hai prescrizioni in monitoraggio."
        )
        return
    
    # Costruiamo il messaggio
    for idx, prescription in enumerate(prescriptions):
        desc = prescription.get("description", "Prescrizione sconosciuta")
        fiscal_code = prescription["fiscal_code"]
        nre = prescription["nre"]
        
        # Mostriamo lo stato delle notifiche
        notifications_enabled = prescription.get("notifications_enabled", True)
        notification_status = "🔔 attive" if notifications_enabled else "🔕 disattivate"
        
        # Mostriamo lo stato della prenotazione automatica
        auto_book_enabled = prescription.get("auto_book_enabled", False)
        auto_book_status = "🤖 attiva" if auto_book_enabled else "🤖 disattivata"
        
        # Mostriamo il limite di mesi se impostato
        months_limit = prescription.get("config", {}).get("months_limit")
        date_filter = f"⏱ entro {months_limit} mesi" if months_limit else "⏱ nessun filtro date"
        
        # Otteniamo il codice della tessera sanitaria se disponibile
        team_card_code = ""
        if "patient_info" in prescription and "teamCard" in prescription["patient_info"]:
            team_card_code = prescription["patient_info"]["teamCard"].get("code", "")
        
        # Mostriamo i dati di contatto se presenti
        contact_info = ""
        if "phone" in prescription and "email" in prescription:
            contact_info = f"   📞 Telefono: {prescription['phone']}\n"
            contact_info += f"   📧 Email: {prescription['email']}\n"
        
        # Aggiungiamo informazioni sull'utente se l'admin sta visualizzando
        user_info = ""
        if is_admin and "telegram_chat_id" in prescription:
            user_info = f" (User ID: {prescription['telegram_chat_id']})"
        
        message += f"{idx+1}. <b>{desc}</b>{user_info}\n"
        message += f"   Codice Fiscale: <code>{fiscal_code}</code>\n"
        message += f"   NRE: <code>{nre}</code>\n"
        
        # Aggiungiamo il codice della tessera sanitaria se disponibile
        if team_card_code:
            message += f"   Tessera Sanitaria: <code>{team_card_code}</code>\n"
            
        message += contact_info
        message += f"   Notifiche: {notification_status} | {date_filter}\n"
        message += f"   Prenotazione automatica: {auto_book_status}\n\n"
    
    await update.message.reply_text(message, parse_mode="HTML")
    
async def check_availability(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Verifica immediatamente la disponibilità delle prescrizioni."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text("🔒 Non sei autorizzato ad utilizzare questa funzione.")
        return
    
    # Notifichiamo all'utente che stiamo iniziando la verifica
    await update.message.reply_text("🔍 Sto verificando le disponibilità... Potrebbe richiedere alcuni minuti.")
    
    # Carichiamo le prescrizioni
    prescriptions = load_input_data()
    
    # Filtriamo solo le prescrizioni dell'utente o tutte se è admin
    is_admin = user_id == int(authorized_users[0]) if authorized_users else False
    
    if not is_admin:
        # Gli utenti normali verificano solo le proprie prescrizioni
        prescriptions = [p for p in prescriptions if p.get("telegram_chat_id") == user_id]
    
    if not prescriptions:
        await update.message.reply_text(
            "Non ci sono prescrizioni da verificare." if is_admin else "Non hai prescrizioni da verificare."
        )
        return
    
    # Carichiamo i dati precedenti
    previous_data = load_previous_data()
    
    # Processiamo ogni prescrizione
    num_processed = 0
    for prescription in prescriptions:
        # Forziamo l'aggiornamento per inviare anche se non ci sono cambiamenti
        old_config = prescription.get("config", {}).copy()
        
        # Modifichiamo temporaneamente la configurazione per forzare la notifica
        temp_config = old_config.copy()
        temp_config["min_changes_to_notify"] = 0
        prescription["config"] = temp_config
        
        # Processiamo la prescrizione
        success, _ = process_prescription(prescription, previous_data, user_id)
        
        # Ripristiniamo la configurazione originale
        prescription["config"] = old_config
        
        if success:
            num_processed += 1
        
        # Piccolo ritardo tra le richieste
        await asyncio.sleep(1)
    
    # Salviamo i dati aggiornati
    save_previous_data(previous_data)
    
    # Notifichiamo il completamento
    await update.message.reply_text(
        f"✅ Verifica completata! {num_processed}/{len(prescriptions)} prescrizioni processate.\n\n"
        "Se sono state trovate disponibilità, riceverai dei messaggi separati con i dettagli."
    )

# =============================================================================
# GESTORI NOTIFICHE
# =============================================================================

async def toggle_notifications(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Abilita o disabilita le notifiche per una prescrizione."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text("🔒 Non sei autorizzato ad utilizzare questa funzione.")
        return
    
    # Carichiamo le prescrizioni
    prescriptions = load_input_data()
    
    # Filtriamo solo le prescrizioni dell'utente o tutte se è admin
    is_admin = user_id == int(authorized_users[0]) if authorized_users else False
    user_prescriptions = []
    
    if is_admin:
        # L'admin vede tutte le prescrizioni
        user_prescriptions = prescriptions
    else:
        # Gli utenti normali vedono solo le proprie
        user_prescriptions = [p for p in prescriptions if p.get("telegram_chat_id") == user_id]
    
    if not user_prescriptions:
        await update.message.reply_text("⚠️ Non hai prescrizioni da gestire.")
        return ConversationHandler.END
    
    # Creiamo i pulsanti per le prescrizioni
    keyboard = []
    
    for idx, prescription in enumerate(user_prescriptions):
        desc = prescription.get("description", "Prescrizione")
        fiscal_code = prescription["fiscal_code"]
        nre = prescription["nre"]
        
        # Controlliamo lo stato attuale delle notifiche
        notifications_enabled = prescription.get("notifications_enabled", True)
        status = "🔔 ON" if notifications_enabled else "🔕 OFF"
        
        # Creiamo un pulsante con identificativo della prescrizione
        keyboard.append([
            InlineKeyboardButton(
                f"{idx+1}. {desc[:25]}... ({status})",
                callback_data=f"toggle_{idx}"
            )
        ])
    
    keyboard.append([InlineKeyboardButton("❌ Annulla", callback_data="cancel_toggle")])
    
    # Salviamo le prescrizioni nei dati dell'utente
    user_data[user_id] = {
        "action": "toggle_notifications",
        "prescriptions": user_prescriptions
    }
    
    await update.message.reply_text(
        "Seleziona la prescrizione per cui vuoi attivare/disattivare le notifiche:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    return WAITING_FOR_PRESCRIPTION_TO_TOGGLE

async def handle_prescription_toggle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la selezione della prescrizione per cui attivare/disattivare le notifiche."""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    callback_data = query.data
    
    if callback_data == "cancel_toggle":
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Estraiamo l'indice della prescrizione
    idx = int(callback_data.split("_")[1])
    user_prescriptions = user_data[user_id]["prescriptions"]
    
    # Controlliamo che l'indice sia valido
    if idx < 0 or idx >= len(user_prescriptions):
        await query.edit_message_text("⚠️ Prescrizione non valida.")
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Otteniamo la prescrizione
    prescription_to_toggle = user_prescriptions[idx]
    
    # Carichiamo tutte le prescrizioni
    all_prescriptions = load_input_data()
    
    # Cerchiamo la prescrizione nel dataset completo
    toggled = False
    for prescription in all_prescriptions:
        if (prescription["fiscal_code"] == prescription_to_toggle["fiscal_code"] and 
            prescription["nre"] == prescription_to_toggle["nre"]):
            
            # Otteniamo lo stato attuale e lo invertiamo
            current_state = prescription.get("notifications_enabled", True)
            prescription["notifications_enabled"] = not current_state
            
            toggled = True
            new_state = prescription["notifications_enabled"]
            break
    
    if toggled:
        # Salviamo le prescrizioni aggiornate
        save_input_data(all_prescriptions)
        
        # Stato da visualizzare nel messaggio
        status_text = "attivate ✅" if new_state else "disattivate ❌"
        
        # Aggiorniamo il messaggio
        await query.edit_message_text(
            f"✅ Notifiche {status_text} per:\n\n"
            f"Descrizione: {prescription_to_toggle.get('description', 'Non disponibile')}\n"
            f"Codice Fiscale: {prescription_to_toggle['fiscal_code']}\n"
            f"NRE: {prescription_to_toggle['nre']}"
        )
    else:
        await query.edit_message_text("⚠️ Impossibile modificare lo stato delle notifiche.")
    
    # Puliamo i dati dell'utente
    user_data.pop(user_id, None)
    
    return ConversationHandler.END


# =============================================================================
# GESTORI PRENOTAZIONI
# =============================================================================

async def book_prescription(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la prenotazione di una prescrizione."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text("🔒 Non sei autorizzato ad utilizzare questa funzione.")
        return
    
    # Carichiamo le prescrizioni
    prescriptions = load_input_data()
    
    # Filtriamo solo le prescrizioni dell'utente o tutte se è admin
    is_admin = user_id == int(authorized_users[0]) if authorized_users else False
    user_prescriptions = []
    
    if is_admin:
        # L'admin vede tutte le prescrizioni
        user_prescriptions = prescriptions
    else:
        # Gli utenti normali vedono solo le proprie
        user_prescriptions = [p for p in prescriptions if p.get("telegram_chat_id") == user_id]
    
    if not user_prescriptions:
        await update.message.reply_text("⚠️ Non hai prescrizioni da prenotare.")
        return ConversationHandler.END
    
    # Creiamo i pulsanti per le prescrizioni
    keyboard = []
    
    for idx, prescription in enumerate(user_prescriptions):
        desc = prescription.get("description", "Prescrizione")
        fiscal_code = prescription["fiscal_code"]
        nre = prescription["nre"]
        
        # Creiamo un pulsante con identificativo della prescrizione
        keyboard.append([
            InlineKeyboardButton(
                f"{idx+1}. {desc[:30]}... ({fiscal_code[-4:]})",
                callback_data=f"book_{idx}"
            )
        ])
    
    # Aggiungiamo un pulsante per annullare
    keyboard.append([InlineKeyboardButton("❌ Annulla", callback_data="cancel_booking")])
    
    # Salviamo le prescrizioni nei dati dell'utente
    user_data[user_id] = {
        "action": "book_prescription",
        "prescriptions": user_prescriptions
    }
    
    await update.message.reply_text(
        "Seleziona la prescrizione da prenotare:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    return WAITING_FOR_BOOKING_CHOICE

async def handle_booking_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    try:
        idx = int(query.data.split("_")[1])
    except Exception as e:
        await query.edit_message_text("⚠️ Errore nella selezione della prescrizione.")
        return ConversationHandler.END

    user_prescriptions = user_data.get(user_id, {}).get("prescriptions", [])
    if idx < 0 or idx >= len(user_prescriptions):
        await query.edit_message_text("⚠️ Prescrizione non valida.")
        user_data.pop(user_id, None)
        return ConversationHandler.END

    prescription = user_prescriptions[idx]
    user_data[user_id]["selected_prescription"] = prescription

    # Se la prescrizione contiene già i dati di contatto, li usiamo
    if prescription.get("phone") and prescription.get("email"):
        user_data[user_id]["phone"] = prescription["phone"]
        user_data[user_id]["email"] = prescription["email"]
    else:
        await query.edit_message_text(
            f"Hai selezionato: {prescription.get('description', 'N/D')}\n\n"
            "Inserisci il tuo numero di telefono:"
        )
        return WAITING_FOR_PHONE

    # Invia subito un messaggio di attesa
    waiting_message = await query.edit_message_text("🔍 Sto cercando le disponibilità...")

    # Avvia il booking workflow per ottenere le disponibilità (slot_choice = -1 indica "mostra lista")
    result = booking_workflow(
        fiscal_code=prescription["fiscal_code"],
        nre=prescription["nre"],
        phone_number=user_data[user_id]["phone"],
        email=user_data[user_id]["email"],
        patient_id=None,
        process_id=None,
        slot_choice=-1  # Indica: "ritorna la lista degli slot"
    )
    
    if result.get("success") and result.get("action") == "list_slots":
        user_data[user_id]["booking_details"] = result
        slots = result.get("slots", [])
        if not slots:
            await waiting_message.edit_text("⚠️ Nessuna disponibilità trovata per questa prescrizione.")
            return ConversationHandler.END

        # Costruiamo i pulsanti per gli slot disponibili
        keyboard = []
        from datetime import datetime
        for slot in slots:
            try:
                date_obj = datetime.strptime(slot["date"], "%Y-%m-%dT%H:%M:%SZ")
                formatted_date = date_obj.strftime("%d/%m/%Y %H:%M")
            except Exception:
                formatted_date = slot["date"]
            keyboard.append([InlineKeyboardButton(
                f"{formatted_date} - {slot['hospital']} ({slot['price']}€)",
                callback_data=f"slot_{slot['index']}"
            )])
        keyboard.append([InlineKeyboardButton("❌ Annulla", callback_data="cancel_slot")])
        
        await waiting_message.edit_text(
            "📋 <b>Disponibilità trovate:</b>\nSeleziona lo slot desiderato:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML"
        )
        return WAITING_FOR_SLOT_CHOICE
    else:
        await waiting_message.edit_text("⚠️ Errore nella ricerca delle disponibilità. Riprova.")
        return ConversationHandler.END

       
async def handle_phone_number(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce l'input del numero di telefono."""
    user_id = update.effective_user.id
    phone = update.message.text.strip()
    
    # Validazione base del numero di telefono (almeno 8 cifre)
    if not re.match("^[0-9+]{8,15}$", phone):
        await update.message.reply_text(
            "⚠️ Il numero di telefono inserito non sembra valido. Deve contenere almeno 8 cifre.\n\n"
            "Per favore, riprova:"
        )
        return WAITING_FOR_PHONE
    
    # Salviamo il numero di telefono
    user_data[user_id]["phone"] = phone
    
    # Chiediamo l'email
    await update.message.reply_text(
        f"Numero di telefono: {phone}\n\n"
        f"Ora inserisci la tua email:"
    )
    
    return WAITING_FOR_EMAIL

async def handle_email(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce l'input dell'email."""
    user_id = update.effective_user.id
    email = update.message.text.strip()
    
    # Validazione base dell'email
    if not re.match(r"[^@]+@[^@]+\.[^@]+", email):
        await update.message.reply_text(
            "⚠️ L'email inserita non sembra valida.\n\n"
            "Per favore, riprova:"
        )
        return WAITING_FOR_EMAIL
    
    # Salviamo l'email
    user_data[user_id]["email"] = email
    
    # Otteniamo la prescrizione
    prescription = user_data[user_id]["selected_prescription"]
    fiscal_code = prescription["fiscal_code"]
    nre = prescription["nre"]
    
    # Inviamo un messaggio di attesa
    loading_message = await update.message.reply_text(
        "🔍 Sto cercando le disponibilità... Attendi un momento."
    )
    
    # Avviamo il processo di ricerca delle disponibilità
    result = booking_workflow(
        fiscal_code=fiscal_code,
        nre=nre,
        phone_number=user_data[user_id]["phone"],
        email=email,
        slot_choice=-1  # Chiediamo la lista delle disponibilità
    )
    
    if not result["success"]:
        await loading_message.delete()
        await update.message.reply_text(
            f"⚠️ Errore nella ricerca delle disponibilità: {result.get('message', 'Errore sconosciuto')}"
        )
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Se abbiamo le disponibilità, le mostriamo all'utente
    if result["action"] == "list_slots":
        user_data[user_id]["booking_details"] = result
        
        # Creiamo una lista delle disponibilità
        slots = result["slots"]
        service_name = result["service"]
        
        if not slots:
            await loading_message.delete()
            await update.message.reply_text(
                "⚠️ Non ci sono disponibilità per questa prescrizione."
            )
            # Puliamo i dati dell'utente
            user_data.pop(user_id, None)
            return ConversationHandler.END
        
        # Creiamo i pulsanti per le disponibilità
        keyboard = []
        
        for slot in slots:
            # Formattiamo la data
            try:
                date_obj = datetime.strptime(slot["date"], "%Y-%m-%dT%H:%M:%SZ")
                formatted_date = date_obj.strftime("%d/%m/%Y %H:%M")
            except:
                formatted_date = slot["date"]
            
            # Creiamo un pulsante per ogni disponibilità
            keyboard.append([
                InlineKeyboardButton(
                    f"{formatted_date} - {slot['hospital']} ({slot['price']}€)",
                    callback_data=f"slot_{slot['index']}"
                )
            ])
        
        # Aggiungiamo un pulsante per annullare
        keyboard.append([InlineKeyboardButton("❌ Annulla", callback_data="cancel_slot")])
        
        # Eliminiamo il messaggio di caricamento
        await loading_message.delete()
        
        # Mostriamo le disponibilità
        await update.message.reply_text(
            f"📋 <b>Disponibilità per {service_name}</b>\n\n"
            f"Seleziona una disponibilità:",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="HTML"
        )
        
        return WAITING_FOR_SLOT_CHOICE
    
    # Se c'è stato un errore
    await loading_message.delete()
    await update.message.reply_text(
        f"⚠️ Errore imprevisto nella ricerca delle disponibilità."
    )
    # Puliamo i dati dell'utente
    user_data.pop(user_id, None)
    return ConversationHandler.END

async def handle_slot_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la selezione della disponibilità."""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    callback_data = query.data
    
    if callback_data == "cancel_slot":
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Estraiamo l'indice dello slot
    slot_idx = int(callback_data.split("_")[1])
    
    # Otteniamo i dettagli dello slot
    booking_details = user_data[user_id]["booking_details"]
    slots = booking_details["slots"]
    
    # Controlliamo che l'indice sia valido
    if slot_idx < 0 or slot_idx >= len(slots):
        await query.edit_message_text("⚠️ Disponibilità non valida.")
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Otteniamo lo slot selezionato
    selected_slot = slots[slot_idx]
    
    # Formattiamo la data
    try:
        date_obj = datetime.strptime(selected_slot["date"], "%Y-%m-%dT%H:%M:%SZ")
        formatted_date = date_obj.strftime("%d/%m/%Y %H:%M")
    except:
        formatted_date = selected_slot["date"]
    
    # Chiediamo conferma all'utente
    await query.edit_message_text(
        f"📅 <b>Conferma Prenotazione</b>\n\n"
        f"Stai per prenotare:\n"
        f"<b>Servizio:</b> {booking_details['service']}\n"
        f"<b>Data:</b> {formatted_date}\n"
        f"<b>Ospedale:</b> {selected_slot['hospital']}\n"
        f"<b>Indirizzo:</b> {selected_slot['address']}\n"
        f"<b>Prezzo:</b> {selected_slot['price']}€\n\n"
        f"Confermi la prenotazione?",
        reply_markup=InlineKeyboardMarkup([
            [
                InlineKeyboardButton("✅ Sì, prenota", callback_data=f"confirm_slot_{slot_idx}"),
                InlineKeyboardButton("❌ No, annulla", callback_data="cancel_slot")
            ]
        ]),
        parse_mode="HTML"
    )
    
    return WAITING_FOR_BOOKING_CONFIRMATION

async def confirm_booking(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la conferma della prenotazione."""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    callback_data = query.data
    
    if callback_data.startswith("cancel_"):
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Estraiamo l'indice dello slot
    slot_idx = int(callback_data.split("_")[2])
    
    # Otteniamo i dettagli necessari
    booking_details = user_data[user_id]["booking_details"]
    prescription = user_data[user_id]["selected_prescription"]
    phone = user_data[user_id]["phone"]
    email = user_data[user_id]["email"]
    
    # Inviamo un messaggio di attesa
    await query.edit_message_text("🔄 Sto effettuando la prenotazione... Attendi un momento.")
    
    # Avviamo il processo di prenotazione
    result = booking_workflow(
        fiscal_code=prescription["fiscal_code"],
        nre=prescription["nre"],
        phone_number=phone,
        email=email,
        patient_id=booking_details.get("patient_id"),
        process_id=booking_details.get("process_id"),
        slot_choice=slot_idx
    )
    
    if not result["success"]:
        await query.edit_message_text(
            f"❌ Errore nella prenotazione: {result.get('message', 'Errore sconosciuto')}"
        )
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Se la prenotazione è andata a buon fine
    if result["action"] == "booked":
        # Formattiamo la data
        try:
            date_obj = datetime.strptime(result["appointment_date"], "%Y-%m-%dT%H:%M:%SZ")
            formatted_date = date_obj.strftime("%d/%m/%Y %H:%M")
        except:
            formatted_date = result["appointment_date"]
        
        # Inviamo il messaggio di conferma
        await query.edit_message_text(
            f"✅ <b>Prenotazione effettuata con successo!</b>\n\n"
            f"<b>Servizio:</b> {result['service']}\n"
            f"<b>Data:</b> {formatted_date}\n"
            f"<b>Ospedale:</b> {result['hospital']}\n"
            f"<b>Indirizzo:</b> {result['address']}\n"
            f"<b>ID Prenotazione:</b> {result['booking_id']}\n\n"
            f"Ti invio il documento di prenotazione.",
            parse_mode="HTML"
        )
        
        # Inviamo il PDF
        pdf_path = result["pdf_path"]
        pdf_content = result["pdf_content"]
        
        # Inviamo il documento come file
        await context.bot.send_document(
            chat_id=user_id,
            document=BytesIO(pdf_content),
            filename=f"prenotazione_{result['booking_id']}.pdf",
            caption=f"Documento di prenotazione per {result['service']} del {formatted_date}"
        )
        
        # Salvare la prenotazione nei dati della prescrizione
        prescriptions = load_input_data()
        for p in prescriptions:
            if p["fiscal_code"] == prescription["fiscal_code"] and p["nre"] == prescription["nre"]:
                if "bookings" not in p:
                    p["bookings"] = []
                p["bookings"].append({
                    "booking_id": result["booking_id"],
                    "date": result["appointment_date"],
                    "hospital": result["hospital"],
                    "address": result["address"],
                    "service": result["service"]
                })
                break
        save_input_data(prescriptions)
    else:
        await query.edit_message_text(
            f"⚠️ Errore imprevisto nella prenotazione."
        )
    
    # Puliamo i dati dell'utente
    user_data.pop(user_id, None)
    return ConversationHandler.END

async def list_bookings(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra le prenotazioni attive dell'utente."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text("🔒 Non sei autorizzato ad utilizzare questa funzione.")
        return
    
    # Carichiamo le prescrizioni
    prescriptions = load_input_data()
    
    # Filtriamo solo le prescrizioni dell'utente o tutte se è admin
    is_admin = user_id == int(authorized_users[0]) if authorized_users else False
    user_prescriptions = []
    
    if is_admin:
        # L'admin vede tutte le prescrizioni
        user_prescriptions = prescriptions
    else:
        # Gli utenti normali vedono solo le proprie
        user_prescriptions = [p for p in prescriptions if p.get("telegram_chat_id") == user_id]
    
    # Raccogliamo le prenotazioni da tutte le prescrizioni
    all_bookings = []
    
    for prescription in user_prescriptions:
        # Se la prescrizione ha prenotazioni salvate
        if "bookings" in prescription and prescription["bookings"]:
            for booking in prescription["bookings"]:
                booking_info = {
                    "booking_id": booking["booking_id"],
                    "date": booking["date"],
                    "hospital": booking["hospital"],
                    "address": booking.get("address", "Indirizzo non disponibile"),
                    "service": booking["service"],
                    "prescription": prescription
                }
                all_bookings.append(booking_info)
    
    # Se non ci sono prenotazioni, verifichiamo con l'API
    if not all_bookings:
        for prescription in user_prescriptions:
            fiscal_code = prescription["fiscal_code"]
            
            # Inviamo un messaggio di attesa
            loading_message = await update.message.reply_text(
                f"🔍 Sto cercando le prenotazioni per {fiscal_code}... Attendi un momento."
            )
            
            # Otteniamo le prenotazioni dall'API
            result = get_user_bookings(fiscal_code)
            
            # Eliminiamo il messaggio di caricamento
            await loading_message.delete()
            
            if result["success"] and result["bookings"]:
                for booking in result["bookings"]:
                    booking_info = {
                        "booking_id": booking["id"],
                        "date": booking.get("startTime", "Data non disponibile"),
                        "hospital": booking.get("hospital", {}).get("name", "Ospedale non disponibile"),
                        "address": booking.get("site", {}).get("address", "Indirizzo non disponibile"),
                        "service": booking.get("services", [{}])[0].get("description", "Servizio non disponibile"),
                        "prescription": prescription,
                        "from_api": True
                    }
                    all_bookings.append(booking_info)
    
    # Se non ci sono prenotazioni
    if not all_bookings:
        await update.message.reply_text("📝 Non ci sono prenotazioni attive.")
        return
    
    # Ordiniamo le prenotazioni per data
    all_bookings.sort(key=lambda x: x["date"])
    
    # Creiamo il messaggio con le prenotazioni
    message = "📝 <b>Le tue prenotazioni attive:</b>\n\n"
    
    for idx, booking in enumerate(all_bookings):
        # Formattiamo la data
        try:
            date_obj = datetime.strptime(booking["date"], "%Y-%m-%dT%H:%M:%SZ")
            formatted_date = date_obj.strftime("%d/%m/%Y %H:%M")
        except:
            formatted_date = booking["date"]
        
        message += f"{idx+1}. <b>{booking['service']}</b>\n"
        message += f"   📅 Data: {formatted_date}\n"
        message += f"   🏥 Ospedale: {booking['hospital']}\n"
        message += f"   📍 Indirizzo: {booking['address']}\n"
        message += f"   🆔 ID: {booking['booking_id']}\n\n"
    
    # Aggiungiamo un pulsante per disdire una prenotazione
    keyboard = [[InlineKeyboardButton("❌ Disdici una prenotazione", callback_data="cancel_appointment")]]
    
    await update.message.reply_text(
        message,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="HTML"
    )

async def start_cancel_booking(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Avvia il processo di cancellazione di una prenotazione."""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    
    # Carichiamo le prescrizioni
    prescriptions = load_input_data()
    
    # Filtriamo solo le prescrizioni dell'utente o tutte se è admin
    is_admin = user_id == int(authorized_users[0]) if authorized_users else False
    user_prescriptions = []
    
    if is_admin:
        # L'admin vede tutte le prescrizioni
        user_prescriptions = prescriptions
    else:
        # Gli utenti normali vedono solo le proprie
        user_prescriptions = [p for p in prescriptions if p.get("telegram_chat_id") == user_id]
    
    # Raccogliamo le prenotazioni da tutte le prescrizioni
    all_bookings = []
    
    for prescription in user_prescriptions:
        # Se la prescrizione ha prenotazioni salvate
        if "bookings" in prescription and prescription["bookings"]:
            for booking in prescription["bookings"]:
                booking_info = {
                    "booking_id": booking["booking_id"],
                    "date": booking["date"],
                    "hospital": booking["hospital"],
                    "address": booking.get("address", "Indirizzo non disponibile"),
                    "service": booking["service"],
                    "prescription": prescription
                }
                all_bookings.append(booking_info)
    
    # Se non ci sono prenotazioni, verifichiamo con l'API
    if not all_bookings:
        for prescription in user_prescriptions:
            fiscal_code = prescription["fiscal_code"]
            
            # Inviamo un messaggio di attesa
            await query.edit_message_text(
                f"🔍 Sto cercando le prenotazioni per {fiscal_code}... Attendi un momento."
            )
            
            # Otteniamo le prenotazioni dall'API
            from modules.booking_client import get_user_bookings
            result = get_user_bookings(fiscal_code)
            
            if result["success"] and result["bookings"]:
                for booking in result["bookings"]:
                    booking_info = {
                        "booking_id": booking["id"],
                        "date": booking.get("startTime", "Data non disponibile"),
                        "hospital": booking.get("hospital", {}).get("name", "Ospedale non disponibile"),
                        "address": booking.get("site", {}).get("address", "Indirizzo non disponibile"),
                        "service": booking.get("services", [{}])[0].get("description", "Servizio non disponibile"),
                        "prescription": prescription,
                        "from_api": True
                    }
                    all_bookings.append(booking_info)
    
    # Se non ci sono prenotazioni
    if not all_bookings:
        await query.edit_message_text("📝 Non ci sono prenotazioni attive da disdire.")
        return ConversationHandler.END
    
    # Ordiniamo le prenotazioni per data
    all_bookings.sort(key=lambda x: x["date"])
    
    # Salviamo le prenotazioni nei dati dell'utente
    user_data[user_id] = {
        "action": "cancel_booking",
        "bookings": all_bookings  # Salviamo tutte le prenotazioni
    }
    
    logger.info(f"Trovate {len(all_bookings)} prenotazioni da mostrare per la cancellazione")
    
    # Creiamo i pulsanti per le prenotazioni
    keyboard = []
    
    for idx, booking in enumerate(all_bookings):
        # Formattiamo la data
        try:
            date_obj = datetime.strptime(booking["date"], "%Y-%m-%dT%H:%M:%SZ")
            formatted_date = date_obj.strftime("%d/%m/%Y %H:%M")
        except Exception as e:
            logger.error(f"Errore nella formattazione della data: {e}")
            formatted_date = booking["date"]
        
        keyboard.append([
            InlineKeyboardButton(
                f"{idx+1}. {booking['service']} - {formatted_date}",
                callback_data=f"cancel_book_{idx}"
            )
        ])
    
    # Aggiungiamo un pulsante per annullare
    keyboard.append([InlineKeyboardButton("❌ Annulla", callback_data="cancel_cancel_book")])
    
    await query.edit_message_text(
        "Seleziona la prenotazione da disdire:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    return WAITING_FOR_BOOKING_TO_CANCEL

async def handle_booking_to_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la selezione della prenotazione da disdire."""
    logger.info("Entrato in handle_booking_to_cancel")
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    callback_data = query.data
    
    # Log per debug
    logger.info(f"Callback ricevuta: {callback_data}")
    
    if callback_data == "cancel_cancel_book":
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    try:
        # Estraiamo l'indice della prenotazione
        idx = int(callback_data.split("_")[2])
        logger.info(f"Indice estratto: {idx}")
        
        if user_id not in user_data or "bookings" not in user_data[user_id]:
            await query.edit_message_text("⚠️ Dati di prenotazione non trovati. Riprova.")
            return ConversationHandler.END
            
        user_bookings = user_data[user_id]["bookings"]
        
        # Controlliamo che l'indice sia valido
        if idx < 0 or idx >= len(user_bookings):
            await query.edit_message_text("⚠️ Prenotazione non valida.")
            user_data.pop(user_id, None)
            return ConversationHandler.END
        
        # Otteniamo la prenotazione
        booking_to_cancel = user_bookings[idx]
        
        # Formattiamo la data
        try:
            date_obj = datetime.strptime(booking_to_cancel["date"], "%Y-%m-%dT%H:%M:%SZ")
            formatted_date = date_obj.strftime("%d/%m/%Y %H:%M")
        except:
            formatted_date = booking_to_cancel["date"]
        
        # Chiediamo conferma all'utente
        await query.edit_message_text(
            f"⚠️ <b>Sei sicuro di voler disdire questa prenotazione?</b>\n\n"
            f"<b>Servizio:</b> {booking_to_cancel['service']}\n"
            f"<b>Data:</b> {formatted_date}\n"
            f"<b>Ospedale:</b> {booking_to_cancel['hospital']}\n"
            f"<b>ID Prenotazione:</b> {booking_to_cancel['booking_id']}\n\n"
            f"Questa operazione è <b>irreversibile</b>!",
            reply_markup=InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("✅ Sì, disdici", callback_data=f"confirm_cancel_{idx}"),
                    InlineKeyboardButton("❌ No, annulla", callback_data="cancel_cancel_book")
                ]
            ]),
            parse_mode="HTML"
        )
        
        return WAITING_FOR_BOOKING_TO_CANCEL
    
    except Exception as e:
        logger.error(f"Errore in handle_booking_to_cancel: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        await query.edit_message_text("⚠️ Si è verificato un errore nel processare la richiesta.")
        if user_id in user_data:
            user_data.pop(user_id, None)
        return ConversationHandler.END

async def confirm_cancel_booking(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la conferma della disdetta della prenotazione."""
    logger.info("Entrato in confirm_cancel_booking")
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    callback_data = query.data
    
    # Log per debug
    logger.info(f"Callback conferma cancellazione: {callback_data}")
    
    if callback_data.startswith("cancel_cancel"):
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    try:
        # Estraiamo l'indice della prenotazione
        idx = int(callback_data.split("_")[2])
        
        if user_id not in user_data or "bookings" not in user_data[user_id]:
            await query.edit_message_text("⚠️ Dati di prenotazione non trovati. Riprova.")
            return ConversationHandler.END
            
        user_bookings = user_data[user_id]["bookings"]
        
        # Otteniamo la prenotazione
        booking_to_cancel = user_bookings[idx]
        booking_id = booking_to_cancel["booking_id"]
        
        # Inviamo un messaggio di attesa
        await query.edit_message_text("🔄 Sto disdendo la prenotazione... Attendi un momento.")
        
        # Import qui per evitare import circolari
        from modules.booking_client import cancel_booking
        
        try:
            # Disdiciamo la prenotazione
            result = cancel_booking(booking_id)
            
            # Rimuoviamo la prenotazione dalle prescrizioni
            prescriptions = load_input_data()
            for p in prescriptions:
                if "bookings" in p:
                    p["bookings"] = [b for b in p["bookings"] if b["booking_id"] != booking_id]
            save_input_data(prescriptions)
            
            # Inviamo il messaggio di conferma
            await query.edit_message_text(
                f"✅ <b>Prenotazione disdetta con successo!</b>\n\n"
                f"La prenotazione per {booking_to_cancel['service']} è stata disdetta.",
                parse_mode="HTML"
            )
        except Exception as e:
            await query.edit_message_text(
                f"❌ Errore nella disdetta della prenotazione: {str(e)}"
            )
            logger.error(f"Errore nella cancellazione della prenotazione: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
    except Exception as e:
        logger.error(f"Errore in confirm_cancel_booking: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        await query.edit_message_text("⚠️ Si è verificato un errore nel processare la richiesta.")
    
    # Puliamo i dati dell'utente
    if user_id in user_data:
        user_data.pop(user_id, None)
    
    return ConversationHandler.END

async def autobook_prescription(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la prenotazione automatica di una prescrizione (primo slot disponibile)."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text("🔒 Non sei autorizzato ad utilizzare questa funzione.")
        return
    
    # Carichiamo le prescrizioni
    prescriptions = load_input_data()
    
    # Filtriamo solo le prescrizioni dell'utente o tutte se è admin
    is_admin = user_id == int(authorized_users[0]) if authorized_users else False
    user_prescriptions = []
    
    if is_admin:
        # L'admin vede tutte le prescrizioni
        user_prescriptions = prescriptions
    else:
        # Gli utenti normali vedono solo le proprie
        user_prescriptions = [p for p in prescriptions if p.get("telegram_chat_id") == user_id]
    
    if not user_prescriptions:
        await update.message.reply_text("⚠️ Non hai prescrizioni da prenotare automaticamente.")
        return ConversationHandler.END
    
    # Creiamo i pulsanti per le prescrizioni
    keyboard = []
    
    for idx, prescription in enumerate(user_prescriptions):
        desc = prescription.get("description", "Prescrizione")
        fiscal_code = prescription["fiscal_code"]
        nre = prescription["nre"]
        
        # Creiamo un pulsante con identificativo della prescrizione
        keyboard.append([
            InlineKeyboardButton(
                f"{idx+1}. {desc[:30]}... ({fiscal_code[-4:]})",
                callback_data=f"autobook_{idx}"
            )
        ])
    
    # Aggiungiamo un pulsante per annullare
    keyboard.append([InlineKeyboardButton("❌ Annulla", callback_data="cancel_autobook")])
    
    # Salviamo le prescrizioni nei dati dell'utente
    user_data[user_id] = {
        "action": "autobook_prescription",
        "prescriptions": user_prescriptions
    }
    
    await update.message.reply_text(
        "🤖 <b>Prenotazione Automatica</b>\n\n"
        "Questa funzione prenota automaticamente il primo slot disponibile "
        "per la prescrizione selezionata, senza passaggi intermedi.\n\n"
        "Seleziona la prescrizione da prenotare automaticamente:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="HTML"
    )
    
    return WAITING_FOR_BOOKING_CHOICE

async def handle_autobook_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la selezione della prescrizione da prenotare automaticamente."""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    callback_data = query.data
    
    if callback_data == "cancel_autobook":
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        if user_id in user_data:
            user_data.pop(user_id, None)
        return ConversationHandler.END
    
    try:
        # Estraiamo l'indice della prescrizione
        idx = int(callback_data.split("_")[1])
        user_prescriptions = user_data.get(user_id, {}).get("prescriptions", [])
        
        # Controlliamo che l'indice sia valido
        if idx < 0 or idx >= len(user_prescriptions):
            await query.edit_message_text("⚠️ Prescrizione non valida.")
            if user_id in user_data:
                user_data.pop(user_id, None)
            return ConversationHandler.END
        
        # Otteniamo la prescrizione
        prescription_to_book = user_prescriptions[idx]
        user_data[user_id]["selected_prescription"] = prescription_to_book
        
        # Utilizziamo la funzione di utilità per ottenere una descrizione sicura
        description = get_safe_description(prescription_to_book)
        
        # Chiediamo all'utente il numero di telefono
        await query.edit_message_text(
            f"Hai selezionato: {description}\n\n"
            f"Per completare la prenotazione automatica, ho bisogno di alcune informazioni di contatto.\n\n"
            f"Inserisci il tuo numero di telefono:"
        )
        
        return WAITING_FOR_PHONE
    except Exception as e:
        logger.error(f"Errore in handle_autobook_choice: {str(e)}")
        await query.edit_message_text("⚠️ Si è verificato un errore nella selezione della prescrizione.")
        if user_id in user_data:
            user_data.pop(user_id, None)
        return ConversationHandler.END
        
# =============================================================================
# GESTORI FILTRO DATE
# =============================================================================

async def set_date_filter(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Imposta un filtro per le date delle disponibilità."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text("🔒 Non sei autorizzato ad utilizzare questa funzione.")
        return
    
    # Carichiamo le prescrizioni
    prescriptions = load_input_data()
    
    # Filtriamo solo le prescrizioni dell'utente o tutte se è admin
    is_admin = user_id == int(authorized_users[0]) if authorized_users else False
    user_prescriptions = []
    
    if is_admin:
        # L'admin vede tutte le prescrizioni
        user_prescriptions = prescriptions
    else:
        # Gli utenti normali vedono solo le proprie
        user_prescriptions = [p for p in prescriptions if p.get("telegram_chat_id") == user_id]
    
    if not user_prescriptions:
        await update.message.reply_text("⚠️ Non hai prescrizioni da gestire.")
        return ConversationHandler.END
    
    # Creiamo i pulsanti per le prescrizioni
    keyboard = []
    
    for idx, prescription in enumerate(user_prescriptions):
        desc = prescription.get("description", "Prescrizione")
        fiscal_code = prescription["fiscal_code"]
        nre = prescription["nre"]
        
        # Otteniamo il filtro date attuale
        months_limit = prescription.get("config", {}).get("months_limit")
        filter_status = f"⏱ {months_limit} mesi" if months_limit else "⏱ nessun filtro"
        
        # Creiamo un pulsante con identificativo della prescrizione
        keyboard.append([
            InlineKeyboardButton(
                f"{idx+1}. {desc[:25]}... ({filter_status})",
                callback_data=f"date_filter_{idx}"
            )
        ])
    
    keyboard.append([InlineKeyboardButton("❌ Annulla", callback_data="cancel_date_filter")])
    
    # Salviamo le prescrizioni nei dati dell'utente
    user_data[user_id] = {
        "action": "set_date_filter",
        "prescriptions": user_prescriptions
    }
    
    await update.message.reply_text(
        "Seleziona la prescrizione per cui vuoi impostare un filtro sulle date:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    return WAITING_FOR_DATE_FILTER

async def handle_prescription_date_filter(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la selezione della prescrizione per il filtro date."""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    callback_data = query.data
    
    if callback_data == "cancel_date_filter":
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Estraiamo l'indice della prescrizione
    idx = int(callback_data.split("_")[2])
    user_prescriptions = user_data[user_id]["prescriptions"]
    
    # Controlliamo che l'indice sia valido
    if idx < 0 or idx >= len(user_prescriptions):
        await query.edit_message_text("⚠️ Prescrizione non valida.")
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Otteniamo la prescrizione
    prescription = user_prescriptions[idx]
    user_data[user_id]["selected_prescription"] = prescription
    
    # Otteniamo il filtro date attuale
    months_limit = prescription.get("config", {}).get("months_limit")
    current_filter = f"{months_limit} mesi" if months_limit else "nessun filtro"
    
    # Creiamo pulsanti per scelte rapide + opzione personalizzata
    keyboard = [
        [
            InlineKeyboardButton("1 mese", callback_data="months_1"),
            InlineKeyboardButton("2 mesi", callback_data="months_2"),
            InlineKeyboardButton("3 mesi", callback_data="months_3")
        ],
        [
            InlineKeyboardButton("6 mesi", callback_data="months_6"),
            InlineKeyboardButton("12 mesi", callback_data="months_12"),
            InlineKeyboardButton("Nessun limite", callback_data="months_0")
        ],
        [InlineKeyboardButton("Personalizzato...", callback_data="months_custom")],
        [InlineKeyboardButton("❌ Annulla", callback_data="cancel_months")]
    ]
    
    await query.edit_message_text(
        f"Prescrizione: {prescription.get('description', 'Non disponibile')}\n"
        f"Filtro attuale: {current_filter}\n\n"
        f"Seleziona il periodo massimo entro cui ricevere notifiche di disponibilità:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    return WAITING_FOR_MONTHS_LIMIT

async def handle_months_limit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la selezione del limite di mesi per il filtro date."""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    callback_data = query.data
    
    if callback_data == "cancel_months":
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Se l'utente vuole inserire un valore personalizzato
    if callback_data == "months_custom":
        await query.edit_message_text(
            "Inserisci il numero di mesi entro cui vuoi ricevere notifiche (1-24):"
        )
        return WAITING_FOR_MONTHS_LIMIT
    
    # Altrimenti processiamo la scelta rapida
    months = int(callback_data.split("_")[1])
    
    # Salva la scelta nei dati dell'utente
    user_data[user_id]["months_limit"] = months if months > 0 else None
    
    # Prepara la conferma
    prescription = user_data[user_id]["selected_prescription"]
    filter_text = f"{months} mesi" if months > 0 else "nessun limite"
    
    await query.edit_message_text(
        f"Stai per impostare un filtro di {filter_text} per:\n\n"
        f"Prescrizione: {prescription.get('description', 'Non disponibile')}\n"
        f"Codice Fiscale: {prescription['fiscal_code']}\n"
        f"NRE: {prescription['nre']}\n\n"
        f"Confermi?",
        reply_markup=InlineKeyboardMarkup([
            [
                InlineKeyboardButton("✅ Sì, imposta", callback_data="confirm_date_filter"),
                InlineKeyboardButton("❌ No, annulla", callback_data="cancel_date_filter_confirm")
            ]
        ])
    )
    
    return CONFIRM_DATE_FILTER

async def toggle_auto_booking(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Abilita o disabilita la prenotazione automatica per una prescrizione."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text("🔒 Non sei autorizzato ad utilizzare questa funzione.")
        return
    
    # Carichiamo le prescrizioni
    prescriptions = load_input_data()
    
    # Filtriamo solo le prescrizioni dell'utente o tutte se è admin
    is_admin = user_id == int(authorized_users[0]) if authorized_users else False
    user_prescriptions = []
    
    if is_admin:
        # L'admin vede tutte le prescrizioni
        user_prescriptions = prescriptions
    else:
        # Gli utenti normali vedono solo le proprie
        user_prescriptions = [p for p in prescriptions if p.get("telegram_chat_id") == user_id]
    
    if not user_prescriptions:
        await update.message.reply_text("⚠️ Non hai prescrizioni da gestire.")
        return ConversationHandler.END
    
    # Verifichiamo che le prescrizioni abbiano i dati necessari
    valid_prescriptions = []
    for p in user_prescriptions:
        if "phone" in p and "email" in p:
            valid_prescriptions.append(p)
    
    if not valid_prescriptions:
        await update.message.reply_text(
            "⚠️ Non hai prescrizioni con dati di contatto completi. "
            "Rimuovile e aggiungile nuovamente per inserire telefono ed email."
        )
        return ConversationHandler.END
    
    # Creiamo i pulsanti per le prescrizioni
    keyboard = []
    
    for idx, prescription in enumerate(valid_prescriptions):
        desc = prescription.get("description", "Prescrizione")
        fiscal_code = prescription["fiscal_code"]
        nre = prescription["nre"]
        
        # Controlliamo lo stato attuale della prenotazione automatica
        auto_book_enabled = prescription.get("auto_book_enabled", False)
        status = "🤖 ON" if auto_book_enabled else "🤖 OFF"
        
        # Creiamo un pulsante con identificativo della prescrizione
        keyboard.append([
            InlineKeyboardButton(
                f"{idx+1}. {desc[:25]}... ({status})",
                callback_data=f"auto_book_{idx}"
            )
        ])
    
    keyboard.append([InlineKeyboardButton("❌ Annulla", callback_data="cancel_auto_book")])
    
    # Salviamo le prescrizioni nei dati dell'utente
    user_data[user_id] = {
        "action": "toggle_auto_booking",
        "prescriptions": valid_prescriptions
    }
    
    await update.message.reply_text(
        "Seleziona la prescrizione per cui vuoi attivare/disattivare la prenotazione automatica:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    return WAITING_FOR_AUTO_BOOK_CHOICE

async def handle_auto_book_toggle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la selezione della prescrizione per cui attivare/disattivare la prenotazione automatica."""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    callback_data = query.data
    
    if callback_data == "cancel_auto_book":
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Estraiamo l'indice della prescrizione
    idx = int(callback_data.split("_")[2])
    user_prescriptions = user_data[user_id]["prescriptions"]
    
    # Controlliamo che l'indice sia valido
    if idx < 0 or idx >= len(user_prescriptions):
        await query.edit_message_text("⚠️ Prescrizione non valida.")
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Otteniamo la prescrizione
    prescription_to_toggle = user_prescriptions[idx]
    
    # Carichiamo tutte le prescrizioni
    all_prescriptions = load_input_data()
    
    # Cerchiamo la prescrizione nel dataset completo
    toggled = False
    for prescription in all_prescriptions:
        if (prescription["fiscal_code"] == prescription_to_toggle["fiscal_code"] and 
            prescription["nre"] == prescription_to_toggle["nre"]):
            
            # Otteniamo lo stato attuale e lo invertiamo
            current_state = prescription.get("auto_book_enabled", False)
            prescription["auto_book_enabled"] = not current_state
            
            toggled = True
            new_state = prescription["auto_book_enabled"]
            break
    
    if toggled:
        # Salviamo le prescrizioni aggiornate
        save_input_data(all_prescriptions)
        
        # Stato da visualizzare nel messaggio
        status_text = "attivata ✅" if new_state else "disattivata ❌"
        
        # Testo aggiuntivo per spiegare la funzionalità
        info_text = (
            "Il bot controllerà automaticamente le disponibilità ogni 5 minuti e "
            "prenoterà il primo slot disponibile senza richiedere conferma."
            if new_state else ""
        )
        
        # Aggiorniamo il messaggio
        await query.edit_message_text(
            f"✅ Prenotazione automatica {status_text} per:\n\n"
            f"Descrizione: {prescription_to_toggle.get('description', 'Non disponibile')}\n"
            f"Codice Fiscale: {prescription_to_toggle['fiscal_code']}\n"
            f"NRE: {prescription_to_toggle['nre']}\n\n"
            f"{info_text}"
        )
    else:
        await query.edit_message_text("⚠️ Impossibile modificare lo stato della prenotazione automatica.")
    
    # Puliamo i dati dell'utente
    user_data.pop(user_id, None)
    
    return ConversationHandler.END

async def handle_custom_months_limit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce l'input personalizzato per il limite di mesi."""
    user_id = update.effective_user.id
    text = update.message.text.strip()
    
    # Validazione: deve essere un numero tra 1 e 24
    try:
        months = int(text)
        if months < 1 or months > 24:
            await update.message.reply_text(
                "⚠️ Il valore deve essere compreso tra 1 e 24 mesi. Riprova:"
            )
            return WAITING_FOR_MONTHS_LIMIT
    except ValueError:
        await update.message.reply_text(
            "⚠️ Devi inserire un numero intero. Riprova:"
        )
        return WAITING_FOR_MONTHS_LIMIT
    
    # Salva la scelta nei dati dell'utente
    user_data[user_id]["months_limit"] = months
    
    # Prepara la conferma
    prescription = user_data[user_id]["selected_prescription"]
    
    await update.message.reply_text(
        f"Stai per impostare un filtro di {months} mesi per:\n\n"
        f"Prescrizione: {prescription.get('description', 'Non disponibile')}\n"
        f"Codice Fiscale: {prescription['fiscal_code']}\n"
        f"NRE: {prescription['nre']}\n\n"
        f"Confermi?",
        reply_markup=InlineKeyboardMarkup([
            [
                InlineKeyboardButton("✅ Sì, imposta", callback_data="confirm_date_filter"),
                InlineKeyboardButton("❌ No, annulla", callback_data="cancel_date_filter_confirm")
            ]
        ])
    )
    
    return CONFIRM_DATE_FILTER

async def confirm_date_filter(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Conferma l'impostazione del filtro date."""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    callback_data = query.data
    
    if callback_data == "cancel_date_filter_confirm":
        await query.edit_message_text("❌ Operazione annullata.")
        # Puliamo i dati dell'utente
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    # Altrimenti procediamo con l'aggiornamento
    prescription = user_data[user_id]["selected_prescription"]
    months_limit = user_data[user_id]["months_limit"]
    
    # Carichiamo tutte le prescrizioni
    all_prescriptions = load_input_data()
    
    # Cerchiamo la prescrizione nel dataset completo
    updated = False
    for p in all_prescriptions:
        if (p["fiscal_code"] == prescription["fiscal_code"] and 
            p["nre"] == prescription["nre"]):
            
            # Assicuriamo che esista la configurazione
            if "config" not in p:
                p["config"] = {}
            
            # Aggiorniamo il filtro date
            p["config"]["months_limit"] = months_limit
            
            updated = True
            break
    
    if updated:
        # Salviamo le prescrizioni aggiornate
        save_input_data(all_prescriptions)
        
        # Testo da visualizzare nel messaggio
        filter_text = f"{months_limit} mesi" if months_limit is not None else "nessun limite"
        
        # Aggiorniamo il messaggio
        await query.edit_message_text(
            f"✅ Filtro date impostato a {filter_text} per:\n\n"
            f"Descrizione: {prescription.get('description', 'Non disponibile')}\n"
            f"Codice Fiscale: {prescription['fiscal_code']}\n"
            f"NRE: {prescription['nre']}\n\n"
            f"Ora riceverai notifiche solo per disponibilità entro il periodo specificato."
        )
    else:
        await query.edit_message_text("⚠️ Impossibile aggiornare il filtro date.")
    
    # Puliamo i dati dell'utente
    user_data.pop(user_id, None)
    
    return ConversationHandler.END

# =============================================================================
# GESTORI UTENTI
# =============================================================================

async def show_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra informazioni sul bot."""
    user_id = update.effective_user.id
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        await update.message.reply_text("🔒 Non sei autorizzato ad utilizzare questa funzione.")
        return
    
    await update.message.reply_text(
        "ℹ️ <b>Informazioni sul Bot</b>\n\n"
        "Questo bot monitora le disponibilità del Servizio Sanitario Nazionale (SSN) per le prescrizioni mediche e ti notifica quando ci sono nuove disponibilità.\n\n"
        "<b>Comandi principali:</b>\n"
        "➕ <b>Aggiungi Prescrizione</b> - Monitora una nuova prescrizione\n"
        "➖ <b>Rimuovi Prescrizione</b> - Smetti di monitorare una prescrizione\n"
        "📋 <b>Lista Prescrizioni</b> - Visualizza le prescrizioni monitorate\n"
        "🔄 <b>Verifica Disponibilità</b> - Controlla subito le disponibilità\n"
        "🔔 <b>Gestisci Notifiche</b> - Attiva/disattiva notifiche per una prescrizione\n"
        "⏱ <b>Imposta Filtro Date</b> - Filtra le notifiche entro un periodo di mesi\n"
        "🏥 <b>Prenota</b> - Prenota un appuntamento per una prescrizione\n"
        "🤖 <b>Prenota Automaticamente</b> - Attiva/disattiva la prenotazione automatica\n"
        "📝 <b>Le mie Prenotazioni</b> - Visualizza e gestisci le prenotazioni attive\n\n"
        "<b>Prenotazione Automatica:</b>\n"
        "Quando attivi la prenotazione automatica per una prescrizione, il bot prenota automaticamente il primo slot disponibile utilizzando i dati di contatto salvati, senza richiedere ulteriori conferme.\n\n"
        "<b>Frequenza di controllo:</b> Ogni 5 minuti\n\n"
        "<b>Note:</b>\n"
        "• Il bot notifica solo quando ci sono cambiamenti significativi\n"
        "• Le disponibilità possono variare rapidamente, è consigliabile prenotare il prima possibile\n"
        "• Per problemi o assistenza, contatta l'amministratore",
        parse_mode="HTML"
    )
 
async def authorize_user(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce l'autorizzazione di nuovi utenti."""
    user_id = update.effective_user.id
    
    # Solo l'amministratore può autorizzare nuovi utenti
    # L'amministratore è il primo utente nella lista degli autorizzati
    if not authorized_users or str(user_id) != authorized_users[0]:
        await update.message.reply_text("🔒 Solo l'amministratore può autorizzare nuovi utenti.")
        return
    
    # Memorizziamo che l'utente sta cercando di autorizzare qualcuno
    user_data[user_id] = {"action": "authorizing_user"}
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("❌ Annulla", callback_data="cancel_auth")]
    ])
    
    # Chiediamo l'ID dell'utente da autorizzare
    await update.message.reply_text(
        "Per autorizzare un nuovo utente, invia il suo ID Telegram.\n\n"
        "L'utente può ottenere il proprio ID usando @userinfobot o altri bot simili.",
        reply_markup=keyboard
    )
    return AUTHORIZING


async def handle_cancel_auth(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce la pressione del pulsante '❌ Annulla' durante l'autorizzazione."""
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    if user_id in user_data:
        user_data.pop(user_id, None)
    await query.edit_message_text("❌ Operazione annullata.")
    return ConversationHandler.END

async def handle_auth_user_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce l'inserimento dell'ID utente da autorizzare."""
    user_id = update.effective_user.id
    text = update.message.text.strip()
    
    # Se l'utente ha digitato un comando di annullamento, esegui il cancel
    if text.lower() in ["/cancel", "❌ annulla"]:
        return await cancel_operation(update, context)
    
    if not text.isdigit():
        await update.message.reply_text("⚠️ L'ID utente deve essere un numero. Riprova oppure digita /cancel per annullare:")
        return  # Resta nello stesso stato finché non riceve un input valido
    
    new_user_id = text
    if new_user_id in authorized_users:
        await update.message.reply_text(f"⚠️ L'utente {new_user_id} è già autorizzato.")
        user_data.pop(user_id, None)
        return ConversationHandler.END
    
    authorized_users.append(new_user_id)
    save_authorized_users()
    await update.message.reply_text(f"✅ Utente {new_user_id} autorizzato con successo!")
    user_data.pop(user_id, None)
    return ConversationHandler.END

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce i messaggi di testo e i comandi dai pulsanti."""
    user_id = update.effective_user.id
    text = update.message.text
    
    # Gestione degli input durante le conversazioni
    if user_id in user_data:
        # Se l'utente sta cercando di autorizzare qualcuno
        if user_data[user_id].get("action") == "authorizing_user":
            return await handle_auth_user_id(update, context)
        
        # Se l'utente sta inserendo un valore personalizzato per il filtro date
        if "selected_prescription" in user_data[user_id] and user_data[user_id].get("action") == "set_date_filter":
            return await handle_custom_months_limit(update, context)
        
        # Se l'utente sta inserendo dati per la prenotazione
        if user_data[user_id].get("action") in ["book_prescription", "autobook_prescription"]:
            if "phone" not in user_data[user_id]:
                return await handle_phone_number(update, context)
            elif "email" not in user_data[user_id]:
                return await handle_email(update, context)
    
    # Controlliamo se l'utente è autorizzato
    if str(user_id) not in authorized_users:
        # Se non ci sono utenti autorizzati, il primo utente diventa automaticamente amministratore
        if not authorized_users:
            authorized_users.append(str(user_id))
            save_authorized_users()
            logger.info(f"Primo utente {user_id} aggiunto come amministratore")
            
            # Inviamo un messaggio di benvenuto come amministratore
            keyboard = [
                ["➕ Aggiungi Prescrizione", "➖ Rimuovi Prescrizione"],
                ["📋 Lista Prescrizioni", "🔄 Verifica Disponibilità"],
                ["🔔 Gestisci Notifiche", "⏱ Imposta Filtro Date"],
                ["🏥 Prenota", "🤖 Prenota Automaticamente"],
                ["📝 Le mie Prenotazioni", "ℹ️ Informazioni"],
                ["🔑 Autorizza Utente"]
            ]
            reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
            
            await update.message.reply_text(
                f"👑 Benvenuto, {update.effective_user.first_name}!\n\n"
                "Sei stato impostato come amministratore del bot.\n\n"
                "Questo bot ti aiuterà a monitorare le disponibilità del Servizio Sanitario Nazionale.",
                reply_markup=reply_markup
            )
            return
        else:
            await update.message.reply_text(
                "🔒 Non sei autorizzato ad utilizzare questo bot. Contatta l'amministratore per ottenere l'accesso."
            )
            return
    
    # Gestiamo i comandi dai pulsanti
    if text == "➕ Aggiungi Prescrizione":
        return await add_prescription(update, context)
    elif text == "➖ Rimuovi Prescrizione":
        return await remove_prescription(update, context)
    elif text == "📋 Lista Prescrizioni":
        return await list_prescriptions(update, context)
    elif text == "🔄 Verifica Disponibilità":
        return await check_availability(update, context)
    elif text == "🔔 Gestisci Notifiche":
        return await toggle_notifications(update, context)
    elif text == "⏱ Imposta Filtro Date":
        return await set_date_filter(update, context)
    elif text == "🏥 Prenota":
        return await book_prescription(update, context)
    elif text == "🤖 Prenota Automaticamente":
        return await toggle_auto_booking(update, context)
    elif text == "📝 Le mie Prenotazioni":
        return await list_bookings(update, context)
    elif text == "ℹ️ Informazioni":
        return await show_info(update, context)
    elif text == "🔑 Autorizza Utente":
        return await authorize_user(update, context)
    else:
        # Messaggio di default con la tastiera aggiornata
        await update.message.reply_text(
            "Usa i pulsanti sotto per interagire con il bot.",
            reply_markup=ReplyKeyboardMarkup([
                ["➕ Aggiungi Prescrizione", "➖ Rimuovi Prescrizione"],
                ["📋 Lista Prescrizioni", "🔄 Verifica Disponibilità"],
                ["🔔 Gestisci Notifiche", "⏱ Imposta Filtro Date"],
                ["🏥 Prenota", "🤖 Prenota Automaticamente"],
                ["📝 Le mie Prenotazioni", "ℹ️ Informazioni"],
                ["🔑 Autorizza Utente"]
            ], resize_keyboard=True)
        )

async def error_handler(update, context):
    """Gestisce gli errori del bot."""
    # Otteniamo l'errore
    error = context.error
    
    # Logging avanzato con traccia di errore
    import traceback
    error_trace = traceback.format_exc()
    
    # Logghiamo l'errore dettagliato
    logger.error(f"Errore nell'update {update}: {error}")
    logger.error(f"Traccia dell'errore: {error_trace}")
    
    # Recuperiamo l'ID utente
    user_id = None
    if update.effective_user:
        user_id = update.effective_user.id
    
    # Puliamo i dati dell'utente se possibile
    if user_id and user_id in user_data:
        logger.info(f"Pulizia dati utente per {user_id} dopo errore")
        user_data.pop(user_id, None)
    
    # Informiamo l'utente dell'errore (se possibile)
    if update and update.effective_chat:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="❌ Si è verificato un errore durante l'elaborazione della tua richiesta. "
                 "Per favore, riprova o contatta l'amministratore se il problema persiste."
        )
    
    # Ripristina la tastiera principale se possibile
    if update and update.effective_chat and update.effective_user:
        main_keyboard = ReplyKeyboardMarkup([
            ["➕ Aggiungi Prescrizione", "➖ Rimuovi Prescrizione"],
            ["📋 Lista Prescrizioni", "🔄 Verifica Disponibilità"],
            ["🔔 Gestisci Notifiche", "⏱ Imposta Filtro Date"],
            ["🏥 Prenota", "🤖 Prenota Automaticamente"],
            ["📝 Le mie Prenotazioni", "ℹ️ Informazioni"],
            ["🔑 Autorizza Utente"]
        ], resize_keyboard=True)
        
        try:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="🔄 Sessione ripristinata. Seleziona un'operazione:",
                reply_markup=main_keyboard
            )
        except Exception as e:
            logger.error(f"Errore nel ripristino della tastiera: {e}")


# Funzione per recuperare da errori
async def error_recovery(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestisce il recupero da errori nella conversazione."""
    user_id = update.effective_user.id
    
    # Pulisci i dati dell'utente
    if user_id in user_data:
        user_data.pop(user_id, None)
    
    await update.message.reply_text(
        "⚠️ Si è verificato un problema con l'operazione corrente. "
        "Per favore, ricomincia.",
        reply_markup=ReplyKeyboardMarkup([
            ["➕ Aggiungi Prescrizione", "➖ Rimuovi Prescrizione"],
            ["📋 Lista Prescrizioni", "🔄 Verifica Disponibilità"],
            ["🔔 Gestisci Notifiche", "⏱ Imposta Filtro Date"],
            ["🏥 Prenota", "🤖 Prenota Automaticamente"],
            ["📝 Le mie Prenotazioni", "ℹ️ Informazioni"],
            ["🔑 Autorizza Utente"]
        ], resize_keyboard=True)
    )
    
    return ConversationHandler.END

# =============================================================================
# SETUP HANDLERS
# =============================================================================

def setup_handlers(application):
    """Configura i gestori delle conversazioni per il bot."""
    
    # Gestione dell'aggiunta di prescrizioni con ConversationHandler
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text)
        ],
        states={
            WAITING_FOR_FISCAL_CODE: [
                MessageHandler(filters.Regex("^❌ Annulla$"), cancel_operation),
                CommandHandler("cancel", cancel_operation),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_fiscal_code)
            ],
            WAITING_FOR_NRE: [
                MessageHandler(filters.Regex("^❌ Annulla$"), cancel_operation),
                CommandHandler("cancel", cancel_operation),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_nre)
            ],
            WAITING_FOR_PHONE: [
                MessageHandler(filters.Regex("^❌ Annulla$"), cancel_operation),
                CommandHandler("cancel", cancel_operation),
                # Assicurati che vengano usate le funzioni corrette in base all'azione
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_add_phone)
            ],
            WAITING_FOR_EMAIL: [
                MessageHandler(filters.Regex("^❌ Annulla$"), cancel_operation),
                CommandHandler("cancel", cancel_operation),
                # Questa è la modifica chiave: usiamo un gestore condizionale per l'email
                MessageHandler(filters.TEXT & ~filters.COMMAND, lambda update, context: 
                               handle_add_email(update, context) 
                               if update.effective_user.id in user_data and user_data[update.effective_user.id].get("action") == "add_prescription"
                               else handle_email(update, context))
            ],
            AUTHORIZING: [
                CallbackQueryHandler(handle_cancel_auth, pattern="^cancel"),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_auth_user_id)
            ],
            CONFIRM_ADD: [
                CallbackQueryHandler(confirm_add_prescription)
            ],
            WAITING_FOR_PRESCRIPTION_TO_DELETE: [
                CallbackQueryHandler(handle_prescription_to_delete)
            ],
            WAITING_FOR_PRESCRIPTION_TO_TOGGLE: [
                CallbackQueryHandler(handle_prescription_toggle)
            ],
            WAITING_FOR_DATE_FILTER: [
                CallbackQueryHandler(handle_prescription_date_filter)
            ],
            WAITING_FOR_MONTHS_LIMIT: [
                CallbackQueryHandler(handle_months_limit),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_custom_months_limit)
            ],
            CONFIRM_DATE_FILTER: [
                CallbackQueryHandler(confirm_date_filter)
            ],
            # Stati per la prenotazione
            WAITING_FOR_BOOKING_CHOICE: [
                CallbackQueryHandler(handle_booking_choice, pattern="^book_"),
                CallbackQueryHandler(handle_autobook_choice, pattern="^autobook_"),
                CallbackQueryHandler(cancel_operation, pattern="^cancel_")
            ],
            WAITING_FOR_SLOT_CHOICE: [
                CallbackQueryHandler(handle_slot_choice)
            ],
            WAITING_FOR_BOOKING_CONFIRMATION: [
                CallbackQueryHandler(confirm_booking)
            ],
            WAITING_FOR_AUTO_BOOK_CHOICE: [
                CallbackQueryHandler(handle_auto_book_toggle)
            ],
            WAITING_FOR_BOOKING_TO_CANCEL: [
                CallbackQueryHandler(handle_booking_to_cancel, pattern="^cancel_book_"),
                CallbackQueryHandler(confirm_cancel_booking, pattern="^confirm_cancel_"),
                CallbackQueryHandler(cancel_operation, pattern="^cancel_cancel_book$")
            ]
        },
        fallbacks=[
            CommandHandler("cancel", cancel_operation),
            MessageHandler(filters.Regex("^❌ Annulla$"), cancel_operation),
            # Per recuperare da errori
            MessageHandler(filters.ALL, error_recovery)
        ]
    )
    
    application.add_handler(CommandHandler("cancel", cancel_operation)) # handler globale per il /cancel

    
    # Aggiungiamo i gestori
    application.add_handler(conv_handler)
    
    booking_cancel_handler = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(start_cancel_booking, pattern="^cancel_appointment$")
        ],
        states={
            WAITING_FOR_BOOKING_TO_CANCEL: [
                CallbackQueryHandler(handle_booking_to_cancel, pattern="^cancel_book_"),
                CallbackQueryHandler(confirm_cancel_booking, pattern="^confirm_cancel_"),
                CallbackQueryHandler(cancel_operation, pattern="^cancel_cancel_book$")
            ]
        },
        fallbacks=[
            CallbackQueryHandler(cancel_operation, pattern="^cancel_")
        ],
        name="booking_cancellation"
    )
    
    application.add_handler(booking_cancel_handler)
    
    # Gestore errori
    application.add_error_handler(error_handler)
     
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\modules\data_utils.py ---- 
import os
import json
import logging
from datetime import datetime, timedelta
import fcntl

# Importa costanti e configurazioni dal modulo config
from config import (
    logger, INPUT_FILE, PREVIOUS_DATA_FILE, USERS_FILE,
    authorized_users
)

def load_authorized_users_with_lock():
    """Carica gli utenti autorizzati dal file con lock."""
    global authorized_users
    try:
        if os.path.exists(USERS_FILE):
            with open(USERS_FILE, 'r') as f:
                # Acquisiamo un lock condiviso per la lettura
                fcntl.flock(f, fcntl.LOCK_SH)
                try:
                    loaded_users = json.load(f)
                    if loaded_users:
                        authorized_users.clear()
                        authorized_users.extend(loaded_users)
                        logger.info(f"Caricati {len(authorized_users)} utenti autorizzati")
                finally:
                    # Rilasciamo il lock
                    fcntl.flock(f, fcntl.LOCK_UN)
        else:
            # Se il file non esiste, lo creiamo
            with open(USERS_FILE, 'w') as f:
                # Acquisiamo un lock esclusivo per la scrittura
                fcntl.flock(f, fcntl.LOCK_EX)
                try:
                    json.dump(authorized_users, f)
                finally:
                    fcntl.flock(f, fcntl.LOCK_UN)
            logger.info("Creato nuovo file di utenti autorizzati")
    except Exception as e:
        logger.error(f"Errore nel caricare gli utenti autorizzati: {str(e)}")

def save_authorized_users_with_lock():
    """Salva gli utenti autorizzati su file con lock."""
    try:
        with open(USERS_FILE, 'w') as f:
            # Acquisiamo un lock esclusivo
            fcntl.flock(f, fcntl.LOCK_EX)
            try:
                json.dump(authorized_users, f, indent=2)
            finally:
                fcntl.flock(f, fcntl.LOCK_UN)
        logger.info("Utenti autorizzati salvati con successo")
    except Exception as e:
        logger.error(f"Errore nel salvare gli utenti autorizzati: {str(e)}")

def load_authorized_users():
    """Carica gli utenti autorizzati dal file."""
    global authorized_users
    try:
        if os.path.exists(USERS_FILE):
            with open(USERS_FILE, 'r') as f:
                loaded_users = json.load(f)
                if loaded_users:  # Verifichiamo che il file contenga utenti
                    authorized_users.clear()  # Solo se abbiamo caricato utenti validi
                    authorized_users.extend(loaded_users)
                    logger.info(f"Caricati {len(authorized_users)} utenti autorizzati")
                else:
                    logger.warning("File utenti autorizzati vuoto, mantengo utenti esistenti")
        else:
            # Se il file non esiste, lo creiamo con gli utenti attuali (se presenti)
            with open(USERS_FILE, 'w') as f:
                json.dump(authorized_users, f)
            logger.info(f"Creato nuovo file con {len(authorized_users)} utenti autorizzati")
    except Exception as e:
        logger.error(f"Errore nel caricare gli utenti autorizzati: {str(e)}")

def save_authorized_users():
    """Salva gli utenti autorizzati su file."""
    try:
        with open(USERS_FILE, 'w') as f:
            json.dump(authorized_users, f, indent=2)
        logger.info("Utenti autorizzati salvati con successo")
    except Exception as e:
        logger.error(f"Errore nel salvare gli utenti autorizzati: {str(e)}")

def format_date(date_string):
    """Formatta la data ISO in un formato più leggibile."""
    try:
        # Parse della data ISO
        dt = datetime.strptime(date_string, "%Y-%m-%dT%H:%M:%SZ")
        # Formatta la data in italiano
        weekdays = ["Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato", "Domenica"]
        months = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", 
                  "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
        
        weekday = weekdays[dt.weekday()]
        day = dt.day
        month = months[dt.month - 1]
        year = dt.year
        time = dt.strftime("%H:%M")
        
        return f"{weekday} {day} {month} {year}, ore {time}"
    except Exception as e:
        logger.warning(f"Errore nella formattazione della data {date_string}: {str(e)}")
        return date_string

def is_date_within_range(date_str, months_limit=None):
    """
    Verifica se una data è compresa nell'intervallo di oggi fino a X mesi.
    
    Args:
        date_str: La data in formato ISO da verificare
        months_limit: Il numero di mesi limite. Se None, non c'è limite
    
    Returns:
        bool: True se la data è nell'intervallo, False altrimenti
    """
    if months_limit is None:
        return True  # Nessun limite impostato
    
    try:
        # Convertiamo la data da verificare
        date = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ")
        
        # Data di oggi e limite
        today = datetime.now()
        limit_date = today + timedelta(days=30 * months_limit)
        
        # Verifichiamo che la data sia successiva a oggi e entro il limite
        return today <= date <= limit_date
    except Exception as e:
        logger.warning(f"Errore nel verificare l'intervallo di date: {str(e)}")
        return True  # In caso di errore, non filtriamo la data

def load_input_data():
    """Load prescription data from input file."""
    try:
        if os.path.exists(INPUT_FILE):
            with open(INPUT_FILE, 'r') as f:
                return json.load(f)
        # Se il file non esiste, lo creiamo con un array vuoto
        with open(INPUT_FILE, 'w') as f:
            json.dump([], f)
        logger.info("Creato nuovo file di prescrizioni")
        return []
    except Exception as e:
        logger.error(f"Errore nel caricare i dati di input: {str(e)}")
        return []

def save_input_data(data):
    """Salva i dati delle prescrizioni su file con diagnostica migliorata."""
    try:
        file_path = os.path.abspath(INPUT_FILE)
        logger.info(f"Tentativo di salvare i dati delle prescrizioni in: {file_path}")
        
        # Verifica se la directory esiste
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        
        # Salva con indentazione per leggibilità
        with open(file_path, 'w') as f:
            json.dump(data, f, indent=2)
        
        # Verifica che il file esista dopo il salvataggio
        if os.path.exists(file_path):
            file_size = os.path.getsize(file_path)
            logger.info(f"Dati delle prescrizioni salvati con successo ({file_size} bytes)")
            
            # Leggi il file per verificare il contenuto
            with open(file_path, 'r') as f:
                content = json.load(f)
                logger.info(f"Verificato il contenuto: {len(content)} prescrizioni")
        else:
            logger.error(f"Il file {file_path} non esiste dopo il salvataggio")
    except Exception as e:
        logger.error(f"Errore nel salvare i dati delle prescrizioni: {str(e)}")
        
        # Tentativo di recupero
        try:
            # Prova a salvare in una posizione alternativa
            alt_path = os.path.join(os.path.expanduser("~"), "recup_prescriptions.json")
            logger.info(f"Tentativo di salvare in posizione alternativa: {alt_path}")
            
            with open(alt_path, 'w') as f:
                json.dump(data, f, indent=2)
                
            logger.info(f"Dati salvati nella posizione alternativa: {alt_path}")
            logger.info(f"Modifica la variabile INPUT_FILE nel codice: {alt_path}")
        except Exception as alt_e:
            logger.error(f"Anche il salvataggio alternativo è fallito: {str(alt_e)}")

def load_previous_data():
    """Load previous availability data."""
    try:
        if os.path.exists(PREVIOUS_DATA_FILE):
            with open(PREVIOUS_DATA_FILE, 'r') as f:
                return json.load(f)
        # Se il file non esiste, lo creiamo con un dizionario vuoto
        with open(PREVIOUS_DATA_FILE, 'w') as f:
            json.dump({}, f)
        logger.info("Creato nuovo file di dati precedenti")
        return {}
    except Exception as e:
        logger.error(f"Errore nel caricare i dati precedenti: {str(e)}")
        return {}

def save_previous_data(data):
    """Save current availability data for future comparison."""
    try:
        with open(PREVIOUS_DATA_FILE, 'w') as f:
            json.dump(data, f, indent=2)
        logger.info("Dati precedenti salvati con successo")
    except Exception as e:
        logger.error(f"Errore nel salvare i dati precedenti: {str(e)}")

def is_similar_datetime(date1_str, date2_str, minutes_threshold=30):
    """Controlla se due date sono simili entro un certo numero di minuti."""
    try:
        dt1 = datetime.strptime(date1_str, "%Y-%m-%dT%H:%M:%SZ")
        dt2 = datetime.strptime(date2_str, "%Y-%m-%dT%H:%M:%SZ")
        
        # Calcoliamo la differenza in minuti
        diff_minutes = abs((dt2 - dt1).total_seconds() / 60)
        
        # Stessa data (giorno, mese, anno)?
        same_day = (dt1.year == dt2.year and dt1.month == dt2.month and dt1.day == dt2.day)
        
        # Se è lo stesso giorno e la differenza è entro la soglia
        return same_day and diff_minutes <= minutes_threshold
    except Exception:
        return False 
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\modules\locations_db.py ---- 
import json
import os
import logging
import requests
import time

# Imposta il percorso del file JSON che fungerà da "database" delle location
LOCATIONS_DB_FILE = "locations_db.json"

logger = logging.getLogger("LocationsDB")

def geocode_query(query):
    """
    Effettua il geocoding di una query (indirizzo, nome, ecc.) usando Nominatim.
    Restituisce latitudine e longitudine oppure (None, None) in caso di fallimento.
    """
    base_url = "https://nominatim.openstreetmap.org/search"
    params = {
        "q": query,
        "format": "json",
        "limit": 1
    }
    headers = {
        "User-Agent": "RecupMonitor/1.0 (tuo.email@dominio.com)"
    }
    
    try:
        response = requests.get(base_url, params=params, headers=headers)
        response.raise_for_status()
        data = response.json()
        if data:
            lat = float(data[0]["lat"])
            lon = float(data[0]["lon"])
            return lat, lon
    except Exception as e:
        print(f"Errore nel geocoding per la query '{query}': {e}")
    return None, None

def load_locations_db():
    """Carica il database delle location da file JSON."""
    if os.path.exists(LOCATIONS_DB_FILE):
        try:
            with open(LOCATIONS_DB_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except json.JSONDecodeError:
            logger.warning("File JSON delle location corrotto, restituisco dizionario vuoto")
            return {}
    return {}

def save_locations_db(locations):
    """Salva il database delle location su file JSON."""
    try:
        with open(LOCATIONS_DB_FILE, "w", encoding="utf-8") as f:
            json.dump(locations, f, indent=4, ensure_ascii=False)
        logger.info("Database delle location salvato con successo")
    except Exception as e:
        logger.error(f"Errore nel salvataggio del database delle location: {e}")

def update_location_db(hospital_name, address, location_db):
    """
    Aggiorna il dizionario delle location.
    Se latitudine o longitudine sono None, prova a geocodificare usando prima l'indirizzo;
    se questo fallisce, prova con il nome dell'ospedale.
    """
    key = f"{hospital_name} - {address}"
    if key not in location_db:
        # Aggiunge la voce con coordinate vuote
        location_db[key] = {
            "hospital": hospital_name,
            "address": address,
            "latitude": None,
            "longitude": None
        }
    
    # Se le coordinate sono già presenti, non fare nulla
    if location_db[key]["latitude"] is not None and location_db[key]["longitude"] is not None:
        return

    # Prima prova a geocodificare l'indirizzo
    lat, lon = geocode_query(address)
    
    # Se non trova, prova a usare il nome dell'ospedale (magari con aggiunta di "Italia" per contestualizzare)
    if lat is None or lon is None:
        query = f"{hospital_name}, Italia"
        lat, lon = geocode_query(query)
    
    # Se sono state trovate coordinate, aggiornale
    if lat is not None and lon is not None:
        location_db[key]["latitude"] = lat
        location_db[key]["longitude"] = lon
        print(f"Coordinate trovate per {key}: {lat}, {lon}")
    else:
        print(f"Coordinate non trovate per {key}")

    # Per rispettare i limiti di Nominatim, attende 1 secondo tra le richieste
    time.sleep(.3)
 
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\modules\monitoring.py ---- 
import asyncio
import time
import logging
from datetime import datetime

# Importiamo le variabili globali dal modulo principale
from recup_monitor import logger

# Importiamo le funzioni da altri moduli
from modules.data_utils import load_input_data, load_previous_data, save_previous_data
from modules.prescription_processor import process_prescription

async def run_monitoring_loop():
    """Funzione dedicata al loop di monitoraggio da eseguire in un processo separato."""
    # Load previous data
    previous_data = load_previous_data()
    
    while True:
        try:
            start_time = time.time()
            logger.info(f"Inizio ciclo di monitoraggio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            # Load input data
            prescriptions = load_input_data()
            
            # Process each prescription
            for prescription in prescriptions:
                process_prescription(prescription, previous_data)
                # Small delay between processing different prescriptions
                await asyncio.sleep(1)
            
            # Save updated previous data
            save_previous_data(previous_data)
            
            # Calculate time to sleep to maintain 5-minute cycles
            elapsed = time.time() - start_time
            sleep_time = max(300 - elapsed, 1)  # 300 seconds = 5 minutes
            
            logger.info(f"Ciclo completato in {elapsed:.2f} secondi. In attesa del prossimo ciclo tra {sleep_time:.2f} secondi.")
            await asyncio.sleep(sleep_time)
            
        except Exception as e:
            logger.error(f"Errore nel servizio di monitoraggio: {str(e)}")
            # In caso di errore, aspetta 1 minuto e riprova
            await asyncio.sleep(60)

async def start_monitoring():
    """Avvia il thread di monitoraggio delle prescrizioni."""
    # Load previous data
    previous_data = load_previous_data()
    
    while True:
        try:
            start_time = time.time()
            logger.info(f"Inizio ciclo di monitoraggio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            
            # Load input data
            prescriptions = load_input_data()
            
            # Process each prescription
            for prescription in prescriptions:
                process_prescription(prescription, previous_data)
                # Small delay between processing different prescriptions
                await asyncio.sleep(1)
            
            # Save updated previous data
            save_previous_data(previous_data)
            
            # Calculate time to sleep to maintain 5-minute cycles
            elapsed = time.time() - start_time
            sleep_time = max(300 - elapsed, 1)  # 300 seconds = 5 minutes
            
            logger.info(f"Ciclo completato in {elapsed:.2f} secondi. In attesa del prossimo ciclo tra {sleep_time:.2f} secondi.")
            await asyncio.sleep(sleep_time)
            
        except Exception as e:
            logger.error(f"Errore nel servizio di monitoraggio: {str(e)}")
            # In caso di errore, aspetta 1 minuto e riprova
            await asyncio.sleep(60) 
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\modules\prescription_processor.py ---- 
import asyncio, logging, json, os

# Importiamo le variabili globali e funzioni da altri moduli
from recup_monitor import logger, TELEGRAM_TOKEN  # Importa il token Telegram

from modules.api_client import (
    get_access_token, update_device_token, get_patient_info, 
    get_doctor_info, check_prescription, get_prescription_details,
    get_availabilities
)
from modules.data_utils import (
    load_input_data, save_input_data, is_date_within_range,
    is_similar_datetime, format_date
)

from modules.locations_db import update_location_db


def compare_availabilities(previous, current, fiscal_code, nre, prescription_name="", cf_code="", config=None):
    """Compare previous and current availabilities with configuration per prescrizione."""
    # Configurazione predefinita se non specificata
    default_config = {
        "only_new_dates": True,
        "notify_removed": False,
        "min_changes_to_notify": 2,
        "time_threshold_minutes": 60,
        "show_all_current": True,  # Mostra tutte le disponibilità attuali
        "months_limit": None       # Nessun limite di mesi predefinito
    }
    
    # Usa la configurazione fornita o quella predefinita
    if config is None:
        config = default_config
    else:
        # Merge delle configurazioni, mantenendo i valori forniti
        for key, value in default_config.items():
            if key not in config:
                config[key] = value
    
    # Se è la prima volta che controlliamo questa prescrizione
    if not previous or not current:
        # Se non c'erano dati precedenti, consideriamo tutto come nuovo ma non spammiamo
        if not previous and len(current) > 0:
            # Filtriamo le disponibilità in base al limite di mesi
            months_limit = config.get("months_limit")
            if months_limit is not None:
                filtered_current = [
                    avail for avail in current 
                    if is_date_within_range(avail['date'], months_limit)
                ]
            else:
                filtered_current = current
            
            # Se non ci sono disponibilità nel range, non mostriamo nulla
            if not filtered_current:
                return None
                
            # Preparazione del messaggio con formattazione HTML migliorata
            message = f"""
<b>🔍 Nuova Prescrizione</b>

<b>Codice Fiscale:</b> <code>{fiscal_code}</code>
<b>ID Tessera Sanitaria:</b> <code>{cf_code}</code>
<b>NRE:</b> <code>{nre}</code>
<b>Descrizione:</b> <code>{prescription_name}</code>
"""
            
            # Se c'è un limite di mesi, lo mostriamo
            if months_limit is not None:
                message += f"<b>Filtro:</b> Solo appuntamenti entro {months_limit} mesi\n"
            
            message += f"\n📋 <b>Disponibilità Trovate:</b> {len(filtered_current)}\n"
            
            # Raggruppiamo per ospedale
            hospitals = {}
            for avail in sorted(filtered_current, key=lambda x: x['date']):
                hospital_name = avail['hospital']['name']
                if hospital_name not in hospitals:
                    hospitals[hospital_name] = []
                hospitals[hospital_name].append(avail)
            
            # Mostriamo per ospedale
            for hospital_name, availabilities in hospitals.items():
                message += f"\n<b>{hospital_name}</b>\n"
                message += f"📍 {availabilities[0]['site']['address']}\n"
                
                for avail in sorted(availabilities, key=lambda x: x['date']):
                    message += f"📅 {format_date(avail['date'])} - {avail['price']} €\n"
                
                message += "\n"  # Spazio tra gli ospedali
            
            return message
        return None

    # Otteniamo i valori di configurazione
    only_new_dates = config.get("only_new_dates", True)
    notify_removed = config.get("notify_removed", False)
    min_changes = config.get("min_changes_to_notify", 2)
    time_threshold = config.get("time_threshold_minutes", 60)
    show_all_current = config.get("show_all_current", True)
    months_limit = config.get("months_limit", None)
    
    # Filtriamo le disponibilità attuali in base al limite di mesi
    if months_limit is not None:
        filtered_current = [
            avail for avail in current 
            if is_date_within_range(avail['date'], months_limit)
        ]
    else:
        filtered_current = current
        
    # Filtriamo anche le disponibilità precedenti per avere un confronto corretto
    if months_limit is not None:
        filtered_previous = [
            avail for avail in previous 
            if is_date_within_range(avail['date'], months_limit)
        ]
    else:
        filtered_previous = previous
    
    # Prepara una struttura per i cambiamenti
    changes = {
        "new": [],
        "removed": [],
        "changed": []
    }
    
    # Crea dizionari per un confronto più semplice
    # Usiamo l'ID dell'ospedale come chiave principale per aggregare meglio
    prev_by_hospital = {}
    curr_by_hospital = {}
    
    # Organizziamo i dati per ospedale
    for a in filtered_previous:
        hospital_id = a['hospital'].get('id', 'unknown')
        if hospital_id not in prev_by_hospital:
            prev_by_hospital[hospital_id] = []
        prev_by_hospital[hospital_id].append(a)
    
    for a in filtered_current:
        hospital_id = a['hospital'].get('id', 'unknown')
        if hospital_id not in curr_by_hospital:
            curr_by_hospital[hospital_id] = []
        curr_by_hospital[hospital_id].append(a)
    
    # Lista degli ospedali
    all_hospitals = set(list(prev_by_hospital.keys()) + list(curr_by_hospital.keys()))
    
    # Esaminiamo i cambiamenti per ospedale
    for hospital_id in all_hospitals:
        prev_avails = prev_by_hospital.get(hospital_id, [])
        curr_avails = curr_by_hospital.get(hospital_id, [])
        
        # Costruiamo dizionari per date
        prev_dates = {a['date']: a for a in prev_avails}
        curr_dates = {a['date']: a for a in curr_avails}
        
        # Verifica nuove date
        for date, avail in curr_dates.items():
            if date not in prev_dates:
                # Verifichiamo se si tratta solo di un piccolo cambiamento di orario
                is_minor_change = False
                for prev_date in prev_dates.keys():
                    # Confrontiamo le date ignorando ore e minuti
                    if is_similar_datetime(prev_date, date, time_threshold):
                        # È probabilmente solo un aggiustamento di orario, non una nuova disponibilità
                        is_minor_change = True
                        break
                
                if not is_minor_change:
                    changes["new"].append(avail)
        
        # Verifica date rimosse (solo se notify_removed è True)
        if notify_removed:
            for date, avail in prev_dates.items():
                if date not in curr_dates:
                    # Verifichiamo se si tratta solo di un piccolo cambiamento di orario
                    is_minor_change = False
                    for curr_date in curr_dates.keys():
                        # Confrontiamo le date ignorando ore e minuti
                        if is_similar_datetime(date, curr_date, time_threshold):
                            # È probabilmente solo un aggiustamento di orario, non una rimozione
                            is_minor_change = True
                            break
                    
                    if not is_minor_change:
                        changes["removed"].append(avail)
        
        # Verifica cambiamenti di prezzo (solo se only_new_dates è False)
        if not only_new_dates:
            for date, curr_avail in curr_dates.items():
                if date in prev_dates:
                    prev_avail = prev_dates[date]
                    if prev_avail['price'] != curr_avail['price']:
                        changes["changed"].append({
                            "previous": prev_avail,
                            "current": curr_avail
                        })
    
    # Calcoliamo il totale dei cambiamenti in base alla configurazione
    total_changes = len(changes["new"])
    if notify_removed:
        total_changes += len(changes["removed"])
    if not only_new_dates:
        total_changes += len(changes["changed"])
    
    # Se ci sono abbastanza cambiamenti, costruisci un messaggio
    if total_changes >= min_changes or (len(changes["new"]) > 0 and only_new_dates):
        # Preparazione del messaggio con formattazione HTML migliorata
        message = f"""
<b>🔍 Aggiornamento Prescrizione</b>

<b>Codice Fiscale:</b> <code>{fiscal_code}</code>
<b>ID Tessera Sanitaria:</b> <code>{cf_code}</code>
<b>NRE:</b> <code>{nre}</code>
<b>Descrizione:</b> <code>{prescription_name}</code>
"""
        
        # Se c'è un limite di mesi, lo mostriamo
        if months_limit is not None:
            message += f"<b>Filtro:</b> Solo appuntamenti entro {months_limit} mesi\n"
        
        # Intestazione del messaggio
        if only_new_dates:
            message += f"🆕 <b>Nuove Disponibilità:</b> {len(changes['new'])}\n"
        else:
            message += f"🔄 <b>Cambiamenti:</b> {total_changes}\n"
        
        # Nuove disponibilità
        if changes["new"]:
            message += "\n<b>🟢 Nuove Disponibilità:</b>\n"
            
            # Raggruppiamo per ospedale
            hospitals_new = {}
            for avail in changes["new"]:
                hospital_name = avail['hospital']['name']
                if hospital_name not in hospitals_new:
                    hospitals_new[hospital_name] = []
                hospitals_new[hospital_name].append(avail)
            
            # Mostriamo per ospedale
            for hospital_name, availabilities in hospitals_new.items():
                message += f"\n<b>{hospital_name}</b>\n"
                message += f"📍 {availabilities[0]['site']['address']}\n"
                
                # Ordiniamo le date
                sorted_availabilities = sorted(availabilities, key=lambda x: x['date'])
                
                # Mostriamo tutte le date
                for avail in sorted_availabilities:
                    message += f"📅 {format_date(avail['date'])} - {avail['price']} €\n"
        
        # Disponibilità rimosse (se configurato)
        if notify_removed and changes["removed"]:
            message += "\n<b>🔴 Disponibilità Rimosse:</b>\n"
            hospitals_removed = {}
            for avail in changes["removed"]:
                hospital_name = avail['hospital']['name']
                if hospital_name not in hospitals_removed:
                    hospitals_removed[hospital_name] = []
                hospitals_removed[hospital_name].append(avail)
            
            for hospital_name, availabilities in hospitals_removed.items():
                message += f"\n<b>{hospital_name}</b>\n"
                message += f"📍 {availabilities[0]['site']['address']}\n"
                
                sorted_availabilities = sorted(availabilities, key=lambda x: x['date'])
                
                for avail in sorted_availabilities:
                    message += f"📅 {format_date(avail['date'])}\n"
        
        # Tutte le disponibilità attuali
        if show_all_current and filtered_current:
            message += f"\n📋 <b>Tutte le Disponibilità:</b> {len(filtered_current)}\n"
            
            hospitals = {}
            for avail in filtered_current:
                hospital_name = avail['hospital']['name']
                if hospital_name not in hospitals:
                    hospitals[hospital_name] = []
                hospitals[hospital_name].append(avail)
            
            for hospital_name, availabilities in hospitals.items():
                message += f"\n<b>{hospital_name}</b>\n"
                message += f"📍 {availabilities[0]['site']['address']}\n"
                
                sorted_availabilities = sorted(availabilities, key=lambda x: x['date'])
                
                for avail in sorted_availabilities:
                    message += f"📅 {format_date(avail['date'])} - {avail['price']} €\n"
        
        return message
    
    return None

def process_prescription(prescription, previous_data, chat_id=None):
    """Process a single prescription and check for availability changes."""
    fiscal_code = prescription["fiscal_code"]
    nre = prescription["nre"]
    prescription_key = f"{fiscal_code}_{nre}"
    
    # Otteniamo la configurazione specifica per questa prescrizione
    config = prescription.get("config", {})
    
    # Otteniamo l'ID chat Telegram specifico per questa prescrizione, se presente
    telegram_chat_id = prescription.get("telegram_chat_id", chat_id)
    
    logger.info(f"Elaborazione prescrizione {prescription_key}")
    
    # Step 1: Get access token
    access_token = get_access_token()
    if not access_token:
        return False, "Impossibile ottenere il token di accesso"
    
    # Step 2: Update device token
    update_device_token(access_token)
    
    # Step 3: Get patient information
    patient_info = get_patient_info(fiscal_code)
    if not patient_info or 'content' not in patient_info or not patient_info['content']:
        error_msg = f"Impossibile trovare informazioni per il paziente {fiscal_code}"
        logger.error(error_msg)
        return False, error_msg
        
    # Carichiamo tutte le prescrizioni
    all_prescriptions = load_input_data()
    cf_code = ""
    
    try:
        # Flag per verificare se abbiamo trovato e aggiornato la prescrizione
        prescription_updated = False
        
        # Cerchiamo e aggiorniamo la prescrizione specifica
        for p in all_prescriptions:
            if (p["fiscal_code"] == fiscal_code and 
                p["nre"] == nre):
                
                # Verifichiamo che ci siano informazioni del paziente valide
                if patient_info and 'content' in patient_info and patient_info['content']:
                    patient_details = patient_info['content'][0]
                    
                    # Creiamo un dizionario dettagliato e pulito
                    patient_info_dict = {
                        "firstName": patient_details.get("firstName", "N/A"),
                        "lastName": patient_details.get("lastName", "N/A"),
                        "birthDate": patient_details.get("birthDate", "N/A"),
                        
                        # Codice della tessera sanitaria con gestione più robusta
                        "teamCard": {
                            "code": patient_details.get("teamCard", {}).get("code", "N/A"),
                            "validFrom": patient_details.get("teamCard", {}).get("startDate", "N/A"),
                            "validTo": patient_details.get("teamCard", {}).get("endDate", "N/A")
                        },
                        
                        # Residenza con gestione degli attributi mancanti
                        "residence": " ".join(filter(bool, [
                            patient_details.get('residence', {}).get('address', ''),
                            patient_details.get('residence', {}).get('streetNumber', ''),
                            patient_details.get('residence', {}).get('postalCode', ''),
                            patient_details.get('residence', {}).get('town', {}).get('name', ''),
                            patient_details.get('residence', {}).get('province', {}).get('id', '')
                        ])).strip() or "N/A",
                        
                        # Domicilio con gestione degli attributi mancanti
                        "domicile": " ".join(filter(bool, [
                            patient_details.get('domicile', {}).get('address', ''),
                            patient_details.get('domicile', {}).get('streetNumber', ''),
                            patient_details.get('domicile', {}).get('postalCode', ''),
                            patient_details.get('domicile', {}).get('town', {}).get('name', ''),
                            patient_details.get('domicile', {}).get('province', {}).get('id', '')
                        ])).strip() or "N/A",
                        
                        # Informazioni aggiuntive
                        "birthPlace": f"{patient_details.get('birthPlace', {}).get('name', 'N/A')}, "
                                      f"{patient_details.get('birthProvince', {}).get('id', 'N/A')}",
                        
                        "citizenship": patient_details.get('citizenship', {}).get('name', 'N/A')
                    }
                    
                    cf_code = patient_details.get("teamCard", {}).get("code", "")
                    
                    # Aggiungiamo le informazioni del paziente
                    p["patient_info"] = patient_info_dict
                    
                    # Logghiamo l'aggiornamento
                    logger.info(f"Aggiornate informazioni paziente per prescrizione NRE: {nre}")
                    
                    # Impostiamo il flag di aggiornamento
                    prescription_updated = True
                
                break  # Usciamo dal ciclo dopo aver trovato la prescrizione
        
        # Salviamo solo se abbiamo effettivamente aggiornato qualcosa
        if prescription_updated:
            save_input_data(all_prescriptions)
            logger.info(f"Salvate informazioni paziente per prescrizione NRE: {nre}")
        else:
            logger.warning(f"Nessuna prescrizione trovata per aggiornamento: {fiscal_code}, {nre}")
    
    except Exception as e:
        # Catturiamo e logghiamo eventuali errori durante l'aggiornamento
        logger.error(f"Errore durante l'aggiornamento delle informazioni paziente: {str(e)}")
    
    
    patient_id = patient_info['content'][0]['id']
    
    # Step 4: Get doctor information
    doctor_info = get_doctor_info(fiscal_code)
    if not doctor_info or 'id' not in doctor_info:
        error_msg = f"Impossibile trovare informazioni per il medico del paziente {fiscal_code}"
        logger.error(error_msg)
        return False, error_msg
    
    process_id = doctor_info['id']
    
    # Step 5: Check prescription
    check_prescription_result = check_prescription(patient_id, nre)
    if not check_prescription_result:
        error_msg = f"Impossibile verificare la prescrizione {nre}"
        logger.error(error_msg)
        return False, error_msg
    
    # Step 6: Get prescription details
    prescription_details = get_prescription_details(patient_id, nre)
    if not prescription_details or 'details' not in prescription_details or not prescription_details['details']:
        error_msg = f"Impossibile ottenere i dettagli della prescrizione {nre}"
        logger.error(error_msg)
        return False, error_msg
    
    order_ids = prescription_details['details'][0]['service']['id']
    
    # Ottieni il nome della prescrizione
    prescription_name = "Prescrizione sconosciuta"
    try:
        if 'details' in prescription_details and prescription_details['details']:
            service_description = prescription_details['details'][0]['service'].get('description', '')
            if service_description:
                prescription_name = service_description
    except Exception as e:
        logger.warning(f"Impossibile ottenere il nome della prescrizione: {str(e)}")
    
    # Aggiorniamo il nome della prescrizione nei dati
    prescription["description"] = prescription_name
    
    # Step 7: Get availabilities
    availabilities = get_availabilities(patient_id, process_id, nre, order_ids)
    if not availabilities or 'content' not in availabilities:
        error_msg = f"Impossibile ottenere le disponibilità per {nre}, sei sicuro che non sia già prenotata?"
        logger.error(error_msg)
        return False, error_msg
    
    current_availabilities = availabilities['content']
    
    # *** In questo punto aggiorniamo il database delle location ***
    if os.path.exists("locations.json"):
        with open("locations.json", "r") as f:
            locations_db = json.load(f)
    else:
        locations_db = {}
        
    for slot in current_availabilities:
        hospital_info = slot.get("hospital", {})
        site_info = slot.get("site", {})
        hospital_name = hospital_info.get("name", "Sconosciuto")
        address = site_info.get("address", "Indirizzo non disponibile")
        update_location_db(hospital_name, address, locations_db)
    
    # Salva le modifiche sul file JSON
    with open("locations.json", "w") as f:
        json.dump(locations_db, f, indent=2)
    
    # Compare with previous data to detect changes
    previous_availabilities = previous_data.get(prescription_key, [])
    
    # Confronta e genera un messaggio se ci sono cambiamenti significativi
    changes_message = compare_availabilities(
        previous_availabilities, 
        current_availabilities,
        fiscal_code,
        nre,
        prescription_name,
        cf_code,
        config
    )
    
    # Se ci sono cambiamenti, invia una notifica
    if changes_message:
        logger.info(f"Rilevati cambiamenti significativi per {prescription_key}")
        
        # Controlliamo se le notifiche sono abilitate per questa prescrizione
        notifications_enabled = prescription.get("notifications_enabled", True)  # Default a True
        
        if notifications_enabled:
            try:
                # Utilizziamo il metodo normale invece di quello asincrono per evitare problemi
                import requests
                
                url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
                data = {
                    "chat_id": telegram_chat_id,
                    "text": changes_message,
                    "parse_mode": "HTML"
                }
                
                response = requests.post(url, data=data, timeout=10)
                response.raise_for_status()
                
                logger.info(f"Notifica inviata al chat ID: {telegram_chat_id}")
            except Exception as e:
                logger.error(f"Errore nell'inviare notifica: {str(e)}")
        else:
            logger.info(f"Notifiche disabilitate per {prescription_key}, nessun messaggio inviato")
    else:
        logger.info(f"Nessun cambiamento significativo rilevato per {prescription_key}")
    
    # Update previous data for next comparison
    previous_data[prescription_key] = current_availabilities
    
    auto_book_enabled = prescription.get("auto_book_enabled", False)
    
    # Se ci sono disponibilità e la prenotazione automatica è abilitata
    if auto_book_enabled and current_availabilities:
        # Verifichiamo se la prescrizione ha i dati di contatto necessari
        if "phone" in prescription and "email" in prescription:
            try:
                # Verifichiamo che la prescrizione non sia già prenotata
                if not any(booking.get("booking_id") for booking in prescription.get("bookings", [])):
                    logger.info(f"Tentativo di prenotazione automatica per {prescription_key}")
                    
                    # Importiamo la funzione di prenotazione
                    from modules.booking_client import booking_workflow
                    
                    # Avviamo il processo di prenotazione automatica
                    result = booking_workflow(
                        fiscal_code=fiscal_code,
                        nre=nre,
                        phone_number=prescription["phone"],
                        email=prescription["email"],
                        patient_id=patient_id,
                        process_id=process_id,
                        slot_choice=0  # Il primo slot disponibile
                    )
                    
                    if result["success"] and result["action"] == "booked":
                        # La prenotazione è andata a buon fine!
                        logger.info(f"Prenotazione automatica riuscita per {prescription_key}!")
                        
                        # Formattare la data
                        try:
                            date_obj = datetime.strptime(result["appointment_date"], "%Y-%m-%dT%H:%M:%SZ")
                            formatted_date = date_obj.strftime("%d/%m/%Y %H:%M")
                        except:
                            formatted_date = result["appointment_date"]
                        
                        # Inviamo una notifica all'utente
                        booking_message = f"""
<b>✅ Prenotazione Automatica Completata!</b>

<b>Prescrizione:</b> {prescription_name}
<b>Data:</b> {formatted_date}
<b>Ospedale:</b> {result['hospital']}
<b>Indirizzo:</b> {result['address']}
<b>ID Prenotazione:</b> {result['booking_id']}

La prenotazione è stata effettuata automaticamente. Controlla la tua email per conferma.
"""
                        # Utilizziamo il metodo normale invece di quello asincrono per evitare problemi
                        import requests
                        
                        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
                        data = {
                            "chat_id": telegram_chat_id,
                            "text": booking_message,
                            "parse_mode": "HTML"
                        }
                        
                        response = requests.post(url, data=data, timeout=10)
                        
                        # Invio del PDF come documento
                        url_document = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendDocument"
                        
                        from io import BytesIO
                        
                        files = {
                            'document': ('prenotazione.pdf', BytesIO(result['pdf_content']), 'application/pdf')
                        }
                        
                        data_document = {
                            "chat_id": telegram_chat_id,
                            "caption": f"Documento di prenotazione per {prescription_name} del {formatted_date}"
                        }
                        
                        requests.post(url_document, data=data_document, files=files, timeout=30)
                        
                        # Aggiorniamo la prescrizione per includere la prenotazione
                        all_prescriptions = load_input_data()
                        for p in all_prescriptions:
                            if p["fiscal_code"] == fiscal_code and p["nre"] == nre:
                                if "bookings" not in p:
                                    p["bookings"] = []
                                p["bookings"].append({
                                    "booking_id": result["booking_id"],
                                    "date": result["appointment_date"],
                                    "hospital": result["hospital"],
                                    "address": result["address"],
                                    "service": prescription_name
                                })
                                
                                # Disabilitiamo la prenotazione automatica dopo il successo
                                p["auto_book_enabled"] = False
                                
                                break
                        
                        # Salviamo le modifiche
                        save_input_data(all_prescriptions)
                    elif result["success"] and result["action"] == "list_slots":
                        # Ci sono slot disponibili, ma non è stata completata la prenotazione
                        logger.info(f"Slot disponibili per {prescription_key}, prenotazione non completata")
                    else:
                        # Errore nella prenotazione
                        logger.error(f"Errore nella prenotazione automatica per {prescription_key}: {result.get('message', 'Errore sconosciuto')}")
            except Exception as e:
                logger.error(f"Errore durante la prenotazione automatica: {str(e)}")
    
    # Update previous data for next comparison
    previous_data[prescription_key] = current_availabilities
    
    return True, prescription_name
    
    
    
    
     
---- File: C:\Users\luca.tomei\Downloads\LazioHealthMonitorBot\modules\__init__.py ---- 
 
